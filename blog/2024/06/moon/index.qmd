---
title: "swear not by the moon, the fickle moon"
date: now
description: " a complex prediction algorithm in r"
format:
  html:
    css: styles.css
    code-fold: false
    code-tools: true
    code-overflow: wrap
    code-line-numbers: false
#doi: 
citation: true
draft: true
---

```{r setup, include = FALSE}
library(methods)
set.seed(2899)

knitr::opts_chunk$set(fig.align = "center", fig.retina = 3,
                      fig.width = 5.5, fig.height = (5.5 * 0.618),
                      out.width = "90%", collapse = TRUE, 
                      cache = TRUE, comment = "#>")


options(digits = 9, 
        width = 300)

options(
  rlang_trace_top_env = rlang::current_env(),
  rlang__backtrace_on_error = "none")
```

## monthly changes in her circle orb

The moon has always fascinated me. I bought my first binoculars a few years ago, and instead of looking at stars and galaxies far away, I just looked at the moon. Eversince I was a child, I was entranced by it; her constant pursuit everywhere I went and her sneaky tactics during the day. This year, before the solar eclipse, I decided to do a little digging and look into the algorithm used to determine the phases of the moon. If you're interested, you can find it [here](https://www.agopax.it/Libri_astronomia/pdf/Astronomical%20Algorithms.pdf) in this very dense book by Jean Meeus.

If you didn't know, the times of the new moon, first quarter, full moon, and last quarter are the times at which the moon's longitude, as viewed from our planet, aligns with the sun to form 0$^\circ$, 90$^\circ$, 180$^\circ$, and 270$^\circ$, respectively. As the moon orbits the earth and rotates on its axis, it overlaps with the Sun in varying degrees, and thus light is reflected off of it. This means that to calculate the phases of the moon, we would technically need to know the geocentric[^1] longitude of the Moon and the Sun…and I'm not doing that🙃 so giving up a sliver of accuracy seems the right solution if we want to avoid an unorthodox amount of math.

[^1]: as viewed from the Earth

## quod hodie est, brute?

Astronomers use Julian Ephemeris Days (JDE), or Dynamical Time (DT), as a measure of time to keep track of celestial bodies, and you probably guessed that its name may be derived from emperor Julius Caesar's reform that created a calendar that remained aligned to the sun without having to be updated, **but that would be incorrect**. It has nothing to do with Brutus's uncle. The first year under this calendar is Jan 1, 4,713 BC, which means that 2024 would represent the year 6737 of the Julian era—a pretty nerdy thing to point out, but nobody is reading this, probably.

To find the JDE for any celestial event, we simply subtract 2,451,550 days from Ephemeris Time[^2], which is the number of days from 4713 BC to 1952…don't quote me on that😅

[^2]: adopted in 1952

The times of the mean phases of the moon are then given by:

$$
JDE = 2,451,550.09766 + 29.530588861 k \\
+ 0.00015437 T^{2} \\
- 0.000000150 T^{3} \\
+ 0.00000000073 T^{4}
$$

where an integer value of $k = 0$ gives a new moon[^3], and an increase by .25 gives the next phase, 1st quarter, full moon, and the third or last quarter. Any other value of $k$ is meaningless. I'll create a simple function `modf` that will split an object of type `double` into its integer and decimal parts to figure out the moon phase later down the road. A second function `modr` will reduce any angle to the range between 0–360, and a third function `deg2rad` will convert the degrees to radians if necessary

[^3]: $k = 0$ corresponds to the new moon of Jan 6, 2000, and negative values of $k$ are lunar phases before the year 2000.\

```{r modf, echo = TRUE}

#> Modulus fraction function
modf <- function(k){
     stopifnot(is.numeric(k))
     kint <- trunc(k)
     kfrac <- abs(k - kint)
     kround <- c(kint,kfrac)
     return(kround)
}

#> Modulus reduce angle function
modr <- function(angle){
  stopifnot(is.numeric(angle))
  reduced <- angle%%360
  return(reduced)
}

rad2deg <- function(rad){
  stopfinot(is.numeric(rad))
  degrees <- (rad*180)/(pi)
  return(degrees)
}

deg2rad <- function(deg){
  stopifnot(is.numeric(deg))
  radians <- (deg*pi)/180
  return(radians)
}

test_it <- modf(-3.35)
test <- modr(400)
print(c(test_it,test))
```
### crux of thought…math

An approximate value for $k \approx (year - 2000) × 12.3685$ and the $year$ variable should be taken with decimals to express the month and day of the year. $T$ is the time in Julian centuries since 2000, and we can calculate it with accuracy using $(\frac{k}{1236.85})$ and a term we haven't seen yet, $E = 1 - 0.002516T - 0.0000074T^{2}$ to describe the eccentricity of Earth's orbit around the sun.

The angles for the sun's and the moon's mean anomaly[^4], the moon's latitude and the longitude of the ascending node[^5] of the lunar orbit will be calculated next.

[^4]: distance from the center of the moon/sun measured from the side that is closest to earth assuming movement at a uniform speed in a circular orbit.

[^5]: the moon has an ascending and descending node where it crosses the ecliptic hemisphere from the south or the north, respectively.

We will also take into account 14 planetary arguments and specific angle and time corrections for each phase of the moon to obtain the almost exact date of any phase of the moon within the past, future and current Julian epochs.

### the code

::: callout-note
Almost every function used here except the main function, `modf`,`modr`,`deg2rad`, `rad2deg`, and the `dex.date` functions are taken from Jean Meeus' “Astronomical Algorithms” referred to in the first paragraph.
:::

I'll use `R` to create a function that allows me to calculate the date of any lunar phase any number of years into the future. I'll first create functions to find the mean anomaly, latitude, and longitude. Notice that to find the exact date, I would have to convert the year to a decimal and use it this way.

```{r moon_funk, echo = TRUE}
#> Times of lunar phases in JDE
JDE <- function(k,t){
 jde <- 2451550.09766 + (29.530588861*k) + 
   0.00015437*(t^2) - 0.000000150*(t^3) + 
   0.00000000073*(t^4)
 jde <- round(jde,digits = 6)
 return(jde)
}
#> Calculate E
E <- function(k,t){
  e <- 1 - (0.002516*t) - 0.0000074*(t^2)
  e <- round(e,digits = 6)
  return(e)
}

#> Sun's mean anomaly at time JDE
M <- function(k,t){
  m <- 2.5534 + (29.10535670*k) - 0.0000014*(t^2) - 0.00000011*(t^3)
  m <- modr(round(m, digits = 6))
  m <- deg2rad(m)
  return(m)
}
#> Moon’s mean anomaly at time JDE
M.prime <- function(k,t){
  m_prime <- 201.5643 + (385.81693528*k) + 0.0107582*(t^2) + 
    0.00001238*(t^3) - 0.000000058*(t^4)
  m_prime <- modr(round(m_prime,digits = 6))
  m_prime <- deg2rad(m_prime)
  return(m_prime)
}
#> Moon's argument of latitude
F <- function(k,t){
  f <- 160.7108 + (390.67050284*k) - 0.0016118*(t^2) - 
    0.00000227*(t^3) + 0.000000011*(t^4)
  f <- modr(round(f, digits = 6))
  f <- deg2rad(f)
  return(f)
}

omega <- function(k,t){
  o <- 124.7746 - (1.56375588*k) + 0.0020672*(t^2) + 0.00000215*(t^3)
  o <- modr(round(0, digits = 6))
  o <- deg2rad(o)
  return(o)
}
```

Now, I'll focus on creating a function fo each planetary argument (14 total). Most of these argument take $k$ with one exception $A_{1}$ that also requires $T$. The output of the planetary arguments are expressed in degrees and may have to be reduced to 0–360 and converted to radians. The main function does use every planetary argument to predict the lunar phases so it may be better to provide the arguments as vectors and not functions, but this code is just a rough draft of the final function to be created later.

```{r plargs, echo = TRUE}
#| code-fold: true

A1 <- function(k,t){
  a1 <- 299.77 + 0.107408*k - 0.009173*(t^2)
  a1 <- modr(round(a1, digits = 6))
  a1 <- deg2rad(a1)
  return(a1)
}
A2 <- function(k){
  a2 <- 251.88 + 0.016321*k
  a2 <- modr(round(a2,digits = 6))
  a2 <- deg2rad(a2)
  return(a2)
}
A3 <- function(k){
  a3 <- 251.83 + 26.651886*k
  a3 <- modr(round(a3,digits = 6))
  a3 <- deg2rad(a3)
  return(a3)
}

A4 <- function(k){
  a4 <- 349.42 + 36.412478*k
  a4 <- modr(round(a4,digits = 6))
  a4 <- deg2rad(a4)
  return(a4)
}
A5 <- function(k){
  a5 <- 84.66 + 18.206239*k
  a5 <- modr(round(a5, digits = 6))
  a5 <- deg2rad(a5)
  return(a5)
}
A6 <- function(k){
  a6 <- 141.74 + 53.303771*k
  a6 <- modr(round(a6,digits = 6))
  a6 <- deg2rad(a6)
  return(a6)
}
A7 <- function(k){
  a7 <- 207.14 + 2.453732*k
  a7 <- modr(round(a7, digits = 6))
  a7 <- deg2rad(a7)
  return(a7)
}
A8 <- function(k){
  a8 <- 154.84 + 7.306860*k
  a8 <- modr(round(a8,digits = 6))
  a8 <- deg2rad(a8)
  return(a8)
}
A9 <- function(k){
  a9 <- 34.52 + 27.261239*k
  a9 <- modr(round(a9,digits = 6))
  a9 <- deg2rad(a9)
  return(a9)
}
A10 <- function(k){
  a10 <- 207.19 + 0.121824*k
  a10 <- modr(round(a10, digits = 6))
  a10 <- deg2rad(a10)
  return(a10)
}
A11 <- function(k){
  a11 <- 291.34 + 1.844379*k
  a11 <- modr(round(a11,digits = 6))
  a11 <- deg2rad(a11)
  return(a11)
}
A12 <- function(k){
  a12 <- 161.72 + 24.198154*k
  a12 <- modr(round(a12,digits = 6))
  a12 <- deg2rad(a12)
  return(a12)
}
A13 <- function(k){
  a13 <- 239.56 + 25.513099*k
  a13 <- modr(round(a13,digits = 6))
  a13 <- deg2rad(a13)
  return(a13)
}
A14 <- function(k){
  a14 <- 331.55 + 3.592518*k
  a14 <- modr(round(a14, digits = 6))
  a14 <- deg2rad(a14)
  return(a14)
}
```

I noticed that $k$ is calculated within every planetary argument instead of outside the function in the global environment. I may initiate a function $k$ outside the main unction and just provide $k$'s output to the proceeding algorithm and save time that way.

### the main thing

Now, we'll create the main function with the previous code and add conditions for each moon phase so we can accurately implement the time corrections and calculate the exact date and time of a lunar phase.

Something to keep in mind is that the `date` variable will have to be expressed as a decimal for the algorithm to work. This means that I'll have to transform the date inside the main function before doing any computations.

The output will be in date format so we'll need to look at R's date manipulation capabilities. The built.in `as.Date` function won't work for us this time because it doesn't handle time (HH:MM:SS), we're left with two choices to handle dates, the `chron` package which handles time but doesn't account for timezones or the built.in `POSIX` classes that do manipulate timezones. I'm going with `POSIXlt` so that I can extract time information without pulling from external libraries.

#### …not the main thing

I'll test a simple function to transform a character string in the format `"YYYY/MM/DD"` to a `POSIXlt` date and then return a decimal to represent the number of days completed in any given year.

Also take into account that some years will be leap or century years and this will also have to be dealt with. Additionally, we're calculating the number of days completed up to the current date, which means we'll update our function to use `day - 1` to find the decimal expression for the specified date.

```{r datetest, echo = TRUE}
dex.date <- function(date){
  if (!inherits(date, c("POSIXt", "POSIXct", "POSIXlt", "Date"))) {
    #> Transform to POSIXlt
  POSIX_date <- as.POSIXlt(date)
#> if the format is not found by the function, you can provide                                    
#> your format explicitly by adding the format argument.
  }
  year <- POSIX_date$year + 1900 
#> Pull the year attribute and add 1900, default is to subtract                                   
#> 1900 to provided year
  day <- as.numeric(format(POSIX_date,"%j")) # day of the year 0 - 365
  dy_yrs <- ifelse((year %% 4 == 0 & year %% 100 != 0) | (year %% 400 == 0), 366,365.25)
#> Get the time components
  hour <- POSIX_date$hour
  minute <- POSIX_date$min
  second <- POSIX_date$sec
#> Calculate the fraction of the day
  fraction_day <- (hour * 3600 + minute * 60 + second) / (86400)
  dex_date <- year + (day -1 + fraction_day)/dy_yrs
  return(dex_date)
}

#> Let's test it
test <- dex.date("2027/2/19 23:30:45")
print(test)
```

Alright! The function is accurate up to the fourth significant figure[^6] That's great,but now I have to create a second function to convert from JDE to Gregorian time. I'll use [October 15, 1582](https://en.wikipedia.org/wiki/Gregorian_calendar#:~:text=When%20the%20new%20calendar%20was,of%20weekdays%20was%20not%20affected) as the first day in the Gregorian calendar, which means that the number of Julian days from 4,713 BC to Oct. 15, 1582 is $2299161.05$

[^6]: We can test this by using the `decimal_date` in the lubridate package. The decimal date there is 2027.1369

```{r gregorian, echo = TRUE}
convert.JDE <- function(jde){
  jde <- jde + 0.5
  Z <- trunc(jde)
  F <- jde - Z
  if (Z < 2299161) {
    A <- Z
  } else {
    alpha <- trunc((Z - 1867216.25) / 36524.25)
    A <- Z + 1 + alpha - trunc(alpha / 4)
  }
  B <- A + 1524
  C <- trunc((B - 122.1) / 365.25)
  D <- trunc(365.25 * C)
  E <- trunc((B - D) / 30.6001)

  day <- B - D - trunc(30.6001 * E) + F
  month <- ifelse(E < 14, E - 1, E - 13)
  year <- ifelse(month > 2, C - 4716, C - 4715)

  # Extract the fractional day part for time
  hour <- (day - trunc(day)) * 24
  minute <- (hour - trunc(hour)) * 60
  second <- (minute - trunc(minute)) * 60
  
  # Create a POSIXlt object for the Gregorian date and time
  gregorian_date <- as.POSIXlt(sprintf("%04d-%02d-%02d %02d:%02d:%06.3f",
                                       year, month, trunc(day),
                                       trunc(hour), trunc(minute), second),
                               format = "%Y-%m-%d %H:%M:%OS")
  return(gregorian_date)
}
```

After checking the accuracy of the `convert.JDE` function by using the following examples, we can create third function to convert from Gregorian or calendar time to JDE. This is simply extra work, but it assures us that our JDE calculation is highly accurate and error-free🤞

```{r jdex, echo = FALSE, eval = TRUE}
#| label: jdex
jdex <- data.frame(Calendar = c("2000/01/01 12:00:00", "1999/01/01",
                              "1600/01/01","837/04/10 7:12:00",
                              "1987/06/19 12:00:00","1900/01/01"),
                   JDE = c(2451545.0,2451179.5,
                           2305447.5,2026871.8,
                           2446966.0,2415020.5))

knitr::kable(jdex, "simple", align = "cl",
             caption = "Dates for testing JDE conversion function")
```

The `JDE` function that was created before cannot be used here because the variable $k$ is not needed for calendar transformation. If we were to use it, we would always get a Julian date that's off by 1 - 7 days…I've already tried it.

```{r grtojed, echo = TRUE}
greg.convert<- function(date){
  if (!inherits(date, c("POSIXt", "POSIXct", "POSIXlt", "Date"))) {
    #> Transform to POSIXlt
  POSIX_date <- as.POSIXlt(date)
  }
  Y <- POSIX_date$year + 1900
  M <- POSIX_date$mon + 1
  D <- POSIX_date$mday
  H <- POSIX_date$hour
  mn <- POSIX_date$min
  S <- POSIX_date$sec
  Y_up <- ifelse(M > 2, Y,Y - 1)
  M_up <- ifelse(M > 2,M, M + 12)
  A <- floor(Y_up/100)
  if(Y_up < 1582){ # If looking at Julian calendar
    B = 0
  } else{
    B = 2 - A + floor(A/4)
  }
  D_dec <- (H + mn/60 + S/3600)/24
  jde <- floor(365.25*(Y_up + 4716)) + floor(30.6001*(M_up +1)) + D + D_dec + B - 1524.5
  return(jde)
}
testy <- greg.convert("2027/02/19 23:30:45")
print(testy)
```
We can use Dates table to test the accuracy of this function. One example that caught my attention and wasn't part of the table is the date 3837-04-10 07:12:00. This particular date returned $3122594.8$ and the `convert.JDE` function was 3837-04-10 07:11:60 EDT, which made me think that it was a day with a leap second, but those are unpredictable and not known so far in advance. 

### the main function

With all the parts in place, we can get back to writing the main function. Ideally, a date will be entered, we will calculate $k$, then $T$ to obtain the JDE date which, by the way, is not accurately representing the date of the chosen lunar phase yet. Our algorithm will them find $E, M, M^\prime, F$, and $\Omega$. The fourteen planetary corrections will be applied next, and additional correction for the selected lunar phase will be calculated. We'll then use these corrections to adjust the JDE date and finally convert it to the Gregorian date using the `convert.JDE` function. We can check the accuracy of our results by using the `greg.convert` function.
**Here we go**:

```{r mainthang,evall = TRUE}
calc.MoonPhase <- function(k){
  stopifnot(is.numeric(k))
  
  t <- k / 1236.85
  
  # Mean phase JDE
  jde <- JDE(k, t)
  
  # Anomaly, latitude, and longitude of Sun/Moon
  e <- E(k, t)
  m <- M(k, t)
  mpr <- M.prime(k, t)
  f <- F(k, t)
  om <- omega(k, t)
  
  kfrac <- modf(k)[2]
  
  planet_args <- (
    0.000325 * sin(A1(k, t)) + 
    0.000165 * sin(A2(k)) + 
    0.000164 * sin(A3(k)) +
    0.000126 * sin(A4(k)) + 
    0.000110 * sin(A5(k)) + 
    0.000062 * sin(A6(k)) +
    0.000060 * sin(A7(k)) + 
    0.000056 * sin(A8(k)) + 
    0.000047 * sin(A9(k)) +
    0.000042 * sin(A10(k)) + 
    0.000040 * sin(A11(k)) + 
    0.000037 * sin(A12(k)) +
    0.000035 * sin(A13(k)) + 
    0.000023 * sin(A14(k))
  )
  
  if (kfrac == 0) {
    adj <- (
      -0.40720 * sin(mpr) + 
      0.17241 * e * sin(m) + 
      0.01608 * sin(2 * mpr) + 
      0.01039 * sin(2 * f) + 
      0.00739 * e * sin(mpr - m) - 
      0.00514 * e * sin(mpr + m) +
      0.00208 * (e^2) * sin(2 * m) - 
      0.00111 * sin(mpr - 2 * f) - 
      0.00057 * sin(mpr + 2 * f) +
      0.00056 * e * sin(2 * mpr + m) - 
      0.00042 * sin(3 * mpr) + 
      0.00042 * e * sin(m + 2 * f) +
      0.00038 * e * sin(m - 2 * f) - 
      0.00024 * e * sin(2 * mpr - m) - 
      0.00017 * sin(om) -
      0.00007 * sin(mpr + 2 * m) + 
      0.00004 * sin(2 * mpr - 2 * f) + 
      0.00004 * sin(3 * m) +
      0.00003 * sin(mpr + m - 2 * f) + 
      0.00003 * sin(2 * mpr + 2 * f) - 
      0.00003 * sin(mpr + m + 2 * f) +
      0.00003 * sin(mpr - m + 2 * f) - 
      0.00002 * sin(mpr - m - 2 * f) - 
      0.00002 * sin(3 * mpr + m) +
      0.00002 * sin(4 * mpr)
      )
    
    true_jde <- (jde + adj) + planet_args
     true_date <- convert.JDE(true_jde)
  return(true_date)
    
  } else if (kfrac == .25 || kfrac == .75) {
    adj2 <- (
      -0.62801 * sin(mpr) + 
      0.17172 * e * sin(m) - 
      0.01183 * e * sin(mpr + m) + 
      0.00862 * sin(2 * mpr) + 
      0.00804 * sin(2 * f) + 
      0.00454 * e * sin(mpr - m) + 
      0.00204 * (e^2) * sin(2 * m) - 
      0.00180 * sin(mpr - 2 * f) - 
      0.00070 * sin(mpr + 2 * f) -
      0.00040 * sin(3 * mpr) - 
      0.00034 * e * sin(2 * mpr - m) + 
      0.00032 * e * sin(m + 2 * f) + 
      0.00032 * e * sin(m - 2 * f) - 
      0.00028 * (e^2) * sin(mpr + 2 * m) + 
      0.00027 * e * sin(2 * mpr + m) - 
      0.00017 * sin(om) - 
      0.00005 * sin(mpr - m - 2 * f) + 
      0.00004 * sin(2 * mpr + 2 * f) - 
      0.00004 * sin(mpr + m + 2 * f) + 
      0.00004 * sin(mpr - 2 * m) + 
      0.00003 * sin(mpr + m - 2 * f) + 
      0.00003 * sin(3 * m) + 
      0.00002 * sin(2 * mpr - 2 * f) + 
      0.00002 * sin(mpr - m + 2 * f) - 
      0.00002 * sin(3 * mpr + m)
      )
    
    w <- (
      0.00306 - 0.00038 * e * cos(m) + 
      0.00026 * cos(mpr) - 
      0.00002 * cos(mpr - m) +
         0.00002 * cos(mpr + m) +
      0.00002 * cos(2 * f)
    )
    
    if (kfrac == .25) {
      true_jde <- (jde + adj2) + w + planet_args
      true_date <- convert.JDE(true_jde)
  return(true_date)
      
    } else {
      true_jde <- (jde + adj2) - w + planet_args
      true_date <- convert.JDE(true_jde)
  return(true_date)
      
    }
  } else if (kfrac == .5) {
    adj3 <- (
      -0.40614 * sin(mpr) + 
      0.17302 * e * sin(m) + 
      0.01614 * sin(2 * mpr) + 
            0.01043 * sin(2 * f) + 
      0.00734 * e * sin(mpr - m) - 
      0.00514 * e * sin(mpr + m) + 
            0.00209 * (e^2) * sin(2 * m) - 
      0.00111 * sin(mpr - 2 * f) - 
      0.00057 * sin(mpr + 2 * f) + 
            0.00056 * e * sin(2 * mpr + m) - 
      0.00042 * sin(3 * mpr) + 
      0.00042 * e * sin(m + 2 * f) + 
            0.00038 * e * sin(m - 2 * f) - 
      0.00024 * e * sin(2 * mpr - m) - 
      0.00017 * sin(om) - 
            0.00007 * sin(mpr + 2 * m) + 
      0.00004 * sin(2 * mpr - 2 * f) + 
      0.00004 * sin(3 * m) + 
            0.00003 * sin(mpr + m - 2 * f) + 
      0.00003 * sin(2 * mpr + 2 * f) - 
      0.00003 * sin(mpr + m + 2 * f) + 
            0.00003 * sin(mpr - m + 2 * f) -
      0.00002 * sin(mpr - m - 2 * f) - 
            0.00002 * sin(3 * mpr + m) + 
      0.00002 * sin(4 * mpr)
      )
    
    true_jde <- (jde + adj3) + planet_args
    true_date <- convert.JDE(true_jde)
  return(true_date)
    
  } else if (kfrac > 0 && kfrac < .25) {
    return(cat("Moon is in Waxing Crescent Phase. No valid date returned"))
  } else if (kfrac > .25 && kfrac < .5) {
    return(cat("Moon is in Waxing Gibbous Phase. No valid date returned"))
  } else if (kfrac > .5 && kfrac < .75) {
    return(cat("Moon is in Waning Gibbous Phase. No valid date returned"))
  } else {
    return(cat("Moon is in Waning Crescent Phase. No valid date returned"))
  }
}
```

We can test the function using the following examples of past, present and future lunar phases.
```{r lunarex, echo = FALSE, eval = TRUE}
lunar <- data.frame(Date = c("1901/01/20 14:36","1910/11/10 05:29",
                             "1921/08/18 15:28","2024/07/05 15:57",
                             "2044/01/21 23:48:17"),
                    Phase = c("New Moon","First Quarter",
                              "Full Moon","New Moon", 
                              "First Quarter"))

knitr::kable(lunar, "simple", align = "cl",
             caption = "Dates for testing the lunar phase function")
```
