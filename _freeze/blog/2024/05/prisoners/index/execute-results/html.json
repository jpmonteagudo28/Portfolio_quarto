{
  "hash": "5bd6e35e5f49b6eddb85d4fdbd5acbec",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"the iterated prisoners' dilemma\"\ndate: now\ndescription: \"rudimentary solutions using R\"\nformat:\n  html:\n    css:  ../styles.css\n    code-fold: false\n    code-tools: true\n    code-overflow: wrap\n    code-line-numbers: false\n#doi: \ncitation: true\ndraft: true\n---\n\n\n\n\n\n## not so quickly!\n\nIdeally, all humans would cooperate and live in harmony in a world where evil is not partaken. Unfortunately, that world doesn't exist yet so we're stuck with the question of cooperation. *Should we always cooperate?* Yes…**not so quickly!**.\n\nAs R. Axelrod[^1] put it:\n\n[^1]: The Evolution of Cooperation. *Basic Books, Inc*. New York, 1984\n\n> The Cooperation theory \\[here\\] is based upon an investigation of individuals who pursue their own self–interest wihtout the aid of central authority to force them to cooperate with each other. The reason for assuming self–interest is that it allows an examination of the difficult case when cooperation is not completely based upon a concern for others or upon the welfare of the groups as a whole.\n\n### the prisoner's dilemma\n\nThis iterated version of the dilemma was presented as a hypothetical scenario by R. Axelrod:\n\nTwo bank robbers happen to meet. They decide to pull a job together. The cops nab them, but without enough evidence to convict. They need a confession. And they know both robbers are unlikely to talk, since if neither implicates the other, the cops can keep them in jail for only 30 days.\n\nSo they put the two in separate cells. They go to the first prisoner and say: “If you rat on your partner and he stays mum, we’ll let you go and he’ll do ten years.If you both rat on each other, you’ll both do eight years.” Then they go to the second prisoner and say the same thing.\n\nThe first prisoner thinks it over. “If he rats on me and I don’t rat on him, then I lose big-time. If I rat on him and he doesn’t rat on me, then I win big-time. Either way, the smart move is to rat on him. I’ll just hope he’s a sucker and doesn’t rat on me.” The second prisoner reasons the same way. So they rat on each other, and the cops get their two convictions. If the prisoners had cooperated, both would have gotten off easy. Instead, the rational pursuit of self-interest has put them both in a world of pain.\n\nTo win the game, at least one player must cooperate in the face of betrayal, otherwise both contestants would face unfavorable outcomes.\n\n### the rules\n\nThe rules of Axelrod's iterated prisoner's dilemma:\n\n-   Two players play 200 matches against each other and against an algorithm that betrayed or cooperated at random.\n-   Players obtain three points for mutual cooperation, one for a mutual betrayal, and five for the player who betrays when the other cooperates.\n\n#### the path to follow\n\nI'll attempt to provide four solutions to this problem. The first algorithm will never be the first to betray and will copy the opponent's previous choice. The second solution will betray in response to a cooperation five percent of the time; the third solution will not cooperate first and then imitate each of player 1's choices, and the last one will never betray first, but will retaliate in turn on every remaining move until the end of the game. The official winning strategy was the following:\n\n-   In the first match-up, cooperate.\n-   In every match-up after that, do what the opponent did in the preceding match-up.\n\n#### the tit–for–tat solution\n\nI'll imitate this strategy in the first algorithm and decide on the choices for player 1.\n\nFirst,I'll create a function for player 2 that chooses to cooperate on the first attempt, and copies player 1's previous choice on subsequent moves. To do this, I have to iterate over each of player 1's choices, and store player 2's replies in a new vector.\n\nTo determine the choice order I'll create a vector of length 2 with player 1's original choice and subtract 1 from that choice to obtain the alternative. To create the vector of choices of length $n$, I'll append player 1's original choice to a vector of length $n-1$ ensuring that the first choice is always in position 1 `p1[1]`. The resulting vector will be of length `n`.\n\nWe'll make a vector or player 2's choices of length $n$ equal to `p1`. The first choice will always be cooperation, and all subsequent choices will be player 1's previous response `p1[ i -1]`.\n\n::: {.callout-tip appearance=\"simple\"}\nAlways remember to initialize vectors and perform operations outside the loop, if possible. Doing this will sometimes make your function much, much faster.\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> @rounds: number of rounds or matches in one game\n#> @prob: probability of betrayal and cooperation\n#> @choice: first choice to start the game. Choice inversion will be applied if staring choice = 1\n#> @replace: sampling with replacement based on choice order. A vector of length 2\n\ntit.for.tat <- function(rounds, \n                        prob, \n                        choice,\n                        replace = TRUE,\n                        ...){\n  \n  # Check arguments\n  stopifnot({\n    is.integer(rounds)\n    is.double(prob)\n    is.logical(choice)\n    is.logical(replace)\n  })\n  \n  choice_order <- c(choice, 1 - choice)\n  p1 <- logical(rounds)\n  p2 <- logical(rounds)\n  \n  \n  p1[1] <- choice\n  p2[1] <- TRUE  \n  \n  for (i in 2:rounds) {\n    if (choice_order[1] == TRUE) {\n      inv.prob <- c(prob[2], prob[1])\n      p1[i] <- sample(choice_order, size = 1, replace = replace, prob = inv.prob)\n    } else {\n      p1[i] <- sample(choice_order, size = 1, replace = replace, prob = prob)\n    }\n    \n    p2[i] <- p1[i - 1]\n  }\n  result <- list(P1 = as.numeric(p1), \n                 P2 = as.numeric(p2))\n  return(result)\n}\n\ntable(tit.for.tat(200,prob = c(.459,.237), choice = 0, replace = T))\n#>    P2\n#> P1   0  1\n#>   0 85 47\n#>   1 47 21\n```\n:::\n\n\n\n### the backstabber prober (bsp)\n\nThe only difference between Tit–for–Tat and the BSP[^2] is that we're adding a random component that will cause player 2 to betray player 1 after a cooperation. Player 2 will always cooperate on the first round, but the algorithm will be less predictable than the previous one. Not to spoil it, but I think this one will not do as well as Tit–for–Tat.\n\n[^2]: This strategy follows the Joss strategy featured in the 1984 book by R. Axelrod\n\nTo implement the random component needed to defect on 5% of cooperative responses, I will identify each time player 1 chooses to cooperate and then defect when randomly generated number from the uniform distribution is less than or equal to .05[^3]. If the randomly generated number is greater than my default, I'll revert back to the tit–for–tat strategy.\n\n[^3]: in theory, this should happen 5% of the time for the uniform distribution\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> @prob: probability of betrayal and cooperation\n#> @default: percentage of cooperative responses on which player 2 betrays player 1\n\nprober <- function(rounds, \n                   prob,\n                   choice,\n                   default,\n                   replace = TRUE,\n                   ...){\n  \n   # Check arguments\n  stopifnot({\n    is.integer(rounds)\n    is.double(prob)\n    is.logical(choice)\n    is.double(default)\n    is.logical(replace)\n  })\n  \n  choice_order <- c(choice, 1 - choice)\n  p1 <- logical(rounds)\n  p2 <- logical(rounds)\n  \n  p1[1] <- choice\n  p2[1] <- TRUE  \n  \n  for (i in 2:rounds) {\n    if (choice_order[1] == TRUE) {\n      inv.prob <- c(prob[2], prob[1])\n      p1[i] <- sample(choice_order, size = 1, replace = replace, prob = inv.prob)\n    } else {\n      p1[i] <- sample(choice_order, size = 1, replace = replace, prob = prob)\n    }\n    \n    if (p1[i - 1] == TRUE) {\n      if (runif(1) < default) { # % chance to betray after cooperation\n        p2[i] <- FALSE\n      } else {\n        p2[i] <- TRUE\n      }\n    } else {\n      p2[i] <- p1[i -1] \n    }\n  }\n  result <- list(P1 = as.numeric(p1), \n                 P2 = as.numeric(p2))\n  return(result)\n}\n\ntable(prober(200,prob = c(.459,.237), choice = 0, default = .05, replace = T))\n#>    P2\n#> P1   0  1\n#>   0 68 48\n#>   1 51 33\n```\n:::\n\n\n\n### the corteous cat\n\nA less creative but more common solution is to simply emulate each of player 1 moves. Player 2 will never cooperate first unless player 1 chooses to cooperate. This copy cat algorithm is looking at the current round and not concerned with the previous moves.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n\ncopy.cat <- function(rounds, \n                   prob,\n                   choice,\n                   replace = TRUE,\n                   ...){\n  \n # Check arguments\n  stopifnot({\n    is.integer(rounds)\n    is.double(prob)\n    is.logical(choice)\n    is.logical(replace)\n  })\n  \n  choice_order <- c(choice, 1 - choice)\n  p1 <- logical(rounds)\n  p2 <- logical(rounds)\n  \n  p1[1] <- choice\n  p2[1] <- FALSE\n  \n  for (i in 2:rounds) {\n    if (choice_order[1] == TRUE) {\n      inv.prob <- c(prob[2], prob[1])\n      p1[i] <- sample(choice_order, size = 1, replace = replace, prob = inv.prob)\n    } else {\n      p1[i] <- sample(choice_order, size = 1, replace = replace, prob = prob)\n    }\n    \n    p2[i] <- p1[i]\n  }\n  result <- list(P1 = as.numeric(p1),\n                 P2 = as.numeric(p2))\n  return(result)\n}\n\ntable(copy.cat(200,prob = c(.459,.237), choice = 0, replace = T))\n#>    P2\n#> P1    0   1\n#>   0 140   0\n#>   1   0  60\n```\n:::\n\n\n\n### the squirrel's revenge\n\nThe last algorithm will play nice on the first round but will exact revenge on player 1 until the end of the game[^4].\n\n[^4]: A copy of the aggressive Friedman's algorithm\n\nThe key to achieve such vengeful results is to track when player 1 switches from betrayals to cooperation. Once we identify a cooperation, player 2 will no longer cooperate. I'll only add one argument `zero_switch` to identify when player 1 chooses to defect. This logical vector will automatically switch to true inside the for loop, and will cause player 2 to defect on every move for the remainder of the game.\n\nWe have to pay careful attention to the choice probability here; if the probability of betrayal is higher than cooperation, the revenge algorithm will most likely never cooperate after the first few rounds. This player is a more revengeful fellow. Let's see how to implement it.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n\nexact.revenge <- function(rounds, prob, choice, replace = TRUE,...) {\n  # Check arguments\n  stopifnot({\n    is.integer(rounds)\n    is.double(prob)\n    is.logical(choice)\n    is.logical(replace)\n  })\n  \n  choice_order <- c(choice, 1 - choice)\n  p1 <- logical(rounds)\n  p2 <- logical(rounds)\n  \n  p1[1] <- choice\n  p2[1] <- TRUE \n  \n  zero_switch <- FALSE\n  \n  for (i in 2:rounds) {\n    # Generate player 1's move\n    if (choice_order[1] == TRUE) {\n      inv.prob <- c(prob[2], prob[1])\n      p1[i] <- sample(choice_order, size = 1, replace = replace, prob = inv.prob)\n    } else {\n      p1[i] <- sample(choice_order, size = 1, replace = replace, prob = prob)\n    }\n    \n    # Player 2's response\n    if (p1[i - 1] == FALSE) {\n      zero_switch <- TRUE\n    }\n    p2[i] <- ifelse(zero_switch, FALSE, TRUE)\n  }\n  result <- list(P1 = as.numeric(p1), \n                 P2 = as.numeric(p2))\n  return(result)\n}\n\ntable(exact.revenge(200,prob = c(.159,.437), choice = 1, replace = T))\n#>    P2\n#> P1    0   1\n#>   0  53   1\n#>   1 145   1\n```\n:::\n\n\n\n## algorithm face off\n\nNow that all four algorithms are created, we need a function to evaluate the overall performance in total points after 200 rounds.\n\nFirst, we need an outcome matrix to store the outcome of each choice combination. Then, I have to create a function that repeatedly compares algorithms over `n` number of games. To do this, I would have to update choice order for each game, if necessary; store total number of choices per game in two vectors, one for each player, create a list and evaluate choice outcome against the outcome matrix, and then sum each player's score in the new list to find the total number of points per game. Lastly, I would have to calculate the average number of total points per game and compare the algorithms.\n\nHowever, not every algorithm takes the same list of arguments. The `prober` algorithm requires a default that is not specified anywhere else, and I must implement a comparison function that will take a default probability but only apply it to one of the algorithms no matter its order in the list. To do this, I'll check each argument entered in the function and create two lists, one for the `prober` algorithm and a second for the second algorithm. The first list will contain the default argument and, if there's a value specified, apply it to `prober`, the second will only take a default probability if the algorithm requires a default.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#> arguments include:\n#>  @alg: algorithms to compare\n#>  @rounds: number of rounds in a game\n#>  @prob:   probability of betrayal and cooperation.\n#>  @choice: starting choice.\n#>  @default: percentage of cooperative responses on which player 2 betrays player 1\n#>  @iter: how many games of `n` rounds should be played.\n\ncomp.alg <- function(alg,\n                     iter = NULL,\n                     rounds,\n                     prob,\n                     choice,\n                     replace = TRUE,\n                     default = NULL){\n  #Check arguments\n  stopifnot({\n    is.list(alg)\n    is.numeric(iter) && iter > 0})\n  \n  out <- matrix(c(3,5,0,1), nrow = 2, byrow = TRUE)\n        rownames(out) <- c(\"P1.C\",\"P1.B\")\n        colnames(out) <- c(\"P2.C\",\"P2.B\")\n        \ncreate.args <- function(func,common_args, default){\n  \n  fun_args <- names(formals(func))\n  args <- common_args[names(common_args)%in% fun_args]\n  if(\"default\" %in% fun_args && !is.null(default)){\n    args$default <- default\n  }\n  args\n}\n\ncommon_args <- list(rounds = rounds, \n                        prob = prob,\n                        choice = choice,\n                        replace = TRUE)\n\np1_args <- create.args(alg[[1]], common_args, default)\np2_args <- create.args(alg[[2]], common_args,default)\n  \n  play.game <- function(rounds, \n                        prob,\n                        choice, \n                        default = default,\n                        replace = TRUE) {\n    \n    p1 <- do.call(alg[[1]],p1_args)\n    p2 <- do.call(alg[[2]],p2_args)\n\n   \n  do.score <- function(P1,P2){ # function with O(n) complexity with two ind. for loops\n    \n    n1 <- length(unlist(P1[[1]]))\n    n2 <- length(unlist(P2[[1]]))\n    \n    game_res1 <- data.frame(A1P1 = numeric(n1), \n                           A1P2 = numeric(n1))\n    \n    game_res2 <- data.frame(A2P1 = numeric(n2), \n                           A2P2 = numeric(n2))\n    \n    for(i in seq_along(P1[[1]])){\n      c1 <- P1[[1]][i]\n      c2 <- P1[[2]][i]\n      \n      p1_score <- out[c1 + 1, c2 + 1]\n      p2_score <- t(out)[c1 + 1, c2 + 1]\n      \n      game_res1$A1P1[i] <- p1_score\n      game_res1$A1P2[i] <- p2_score\n    }\n    \n    for (i in seq_along(P2[[1]])){\n      c1 <- P2[[1]][i]\n      c2 <- P2[[2]][i]\n      \n      p1_score <- out[c1 + 1, c2 + 1]\n      p2_score <- t(out)[c1 + 1, c2 + 1]\n      \n      game_res2$A2P1[i] <- p1_score\n      game_res2$A2P2[i] <- p2_score\n    }\n     df_res <- data.frame(game_res1,game_res2)\n     results <- colSums(df_res)\n  }\n  out_game <- do.score(p1,p2)\n  \n  }\n  \n  boot.results <- list2DF(replicate(iter, play.game(rounds = rounds,\n                                prob = prob,\n                                choice = choice,\n                                replace = replace), simplify = FALSE))\n  \n  results <- as.matrix(do.call(rbind,boot.results))\n  \n  \n  return(as.data.frame(results))\n}\n\n#Let's test it\ntest <- comp.alg(c(copy.cat, tit.for.tat), \n                 iter = 500, \n                 rounds = 200, \n                 prob = c(.345, .231), \n                 choice = 0) |> rename(\"CC.P1\" = \"A1P1\",\n                                       \"CC.P2\" = \"A1P2\",\n                                       \"TFT.P1\" = \"A2P1\",\n                                       \"TFT.P2\" = \"A2P2\")\n\nhead(test)\n#>   CC.P1 CC.P2 TFT.P1 TFT.P2\n#> 1   440   440    514    509\n#> 2   458   458    494    494\n#> 3   432   432    473    468\n#> 4   430   430    495    490\n#> 5   426   426    479    474\n#> 6   432   432    485    485\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n\n### individual algorithm performance\n\nLet's now compare each algorithm's performance based on total points obtained per game. Again, the logic here is the same: bootstrap the mean number of points per game and compare them using the `comp.alg` function which takes two algorithms at once and returns a data frame with four columns, one column for each player for both algorithms.\n\n#### average cooperative response\nComputing the average cooperative responses by algorithm after playing 500 games of 200 rounds each should help us understand which algorithm tends to play nice and which ones are more selfish. For the sake of reproducibility, we've set a seed and established an equal, fixed probability of defection and cooperation across algorithms.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Code for algorithm average cooperation\"}\nmean_df <- data.frame(Median = c(replicate(500,median(\n                                sample(copy.cat(200,c(.35,.27),0)$P2,\n                                       replace = T))),\n                              replicate(500,median(\n                                sample(prober(200,c(.35,.27),0,.05)$P2,\n                                       replace = T))),\n                              replicate(500,median(\n                                sample(tit.for.tat(200,c(.35,.27),0)$P2,\n                                       replace = T))),\n                              replicate(500,median(\n                                sample(exact.revenge(200,c(.35,.27),0)$P2,\n                                       replace = T)))),\n                      kind = factor(rep(\n                        c(\"Copy.Cat\", \"Prober\", \"TFT\", \"Revenge\"), \n                                    each = 500),\n    levels = c(\"Copy.Cat\", \"Prober\", \"TFT\", \"Revenge\")))\n\nclrs <- c(\n  \"#FFBE00\",  # MCRN yellow\n  \"#B92F0A\",  # MCRN red\n  \"#7C225C\",  # MCRN maroon\n  \"#394DAA\"   # MCRN Blue\n)\np0 <- ggplot(mean_df, aes(x = mean, fill = kind)) +\n     geom_density(alpha = .45) +\n  ylim(0,25) +\n  labs(x = \"Avg. cooperative response\") +\n  scale_fill_manual(values = clrs) +\n  labs(colour = \"Algorithm\")\n```\n:::\n\n::: {.cell .fig-cap-location-top layout-align=\"center\" lightbox='true'}\n::: {.cell-output-display}\n![Average cooperative responses](img/alg_dist.png){fig-align='center' width=80%}\n:::\n:::\n\n\nThe average cooperative response plot shows that, on average, the tit–for–tat algorithm cooperates more often than any other algorithm except `copy.cat`. \n\n\n::: {.cell .fig-cap-location-top layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\n\nwilcox_gt <- mean_df |> filter(kind == c(\"TFT\",\"Copy.Cat\")) |> \n  pivot_longer(cols = -kind, names_to = \"vars\", \n               values_to = \"values\") |>\ngroup_by(vars) |> summarize(\n  Estimate = wilcox.test(values~kind, conf.int = T)$estimate,\n  Sig. = wilcox.test(values~kind, conf.int = T)$p.value \n  ) |> gt() |> \n  tab_header(\n    title = md(\n      \"*Comparison of Copy.Cat and TFT cooperative responses*\")\n    ) |>\n  cols_label(vars = md(\"**Estimate**\"),\n             Estimate = md(\"**Difference in estimate**\"),\n            Sig. = md(\"**p-value**\")) |>\n  cols_align(align = \"center\") |>\n  opt_table_font(font = google_font(\"EB Garamond\"),\n                 weight = 400,style = \"plain\", add = TRUE) |>\n  tab_style(style = cell_text(font = google_font(\"Ubuntu\")),\n            locations = cells_body()) |>\n   tab_options(column_labels.font.weight = \"bold\",\n              row_group.font.weight = \"bold\") |>\n  data_color(rows = everything(),\n             palette = \"#f9f9f9\")\n\nwilcox_gt\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"ncqosnapri\" style=\"padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n<style>@import url(\"https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap\");\n@import url(\"https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap\");\n#ncqosnapri table {\n  font-family: 'EB Garamond', system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n#ncqosnapri thead, #ncqosnapri tbody, #ncqosnapri tfoot, #ncqosnapri tr, #ncqosnapri td, #ncqosnapri th {\n  border-style: none;\n}\n\n#ncqosnapri p {\n  margin: 0;\n  padding: 0;\n}\n\n#ncqosnapri .gt_table {\n  display: table;\n  border-collapse: collapse;\n  line-height: normal;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: 400;\n  font-style: plain;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#ncqosnapri .gt_caption {\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n\n#ncqosnapri .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#ncqosnapri .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 3px;\n  padding-bottom: 5px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#ncqosnapri .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#ncqosnapri .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#ncqosnapri .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#ncqosnapri .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: bold;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#ncqosnapri .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: bold;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#ncqosnapri .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#ncqosnapri .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#ncqosnapri .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#ncqosnapri .gt_spanner_row {\n  border-bottom-style: hidden;\n}\n\n#ncqosnapri .gt_group_heading {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: bold;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  text-align: left;\n}\n\n#ncqosnapri .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: bold;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#ncqosnapri .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#ncqosnapri .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#ncqosnapri .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#ncqosnapri .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#ncqosnapri .gt_stub_row_group {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n  vertical-align: top;\n}\n\n#ncqosnapri .gt_row_group_first td {\n  border-top-width: 2px;\n}\n\n#ncqosnapri .gt_row_group_first th {\n  border-top-width: 2px;\n}\n\n#ncqosnapri .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#ncqosnapri .gt_first_summary_row {\n  border-top-style: solid;\n  border-top-color: #D3D3D3;\n}\n\n#ncqosnapri .gt_first_summary_row.thick {\n  border-top-width: 2px;\n}\n\n#ncqosnapri .gt_last_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#ncqosnapri .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#ncqosnapri .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#ncqosnapri .gt_last_grand_summary_row_top {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: double;\n  border-bottom-width: 6px;\n  border-bottom-color: #D3D3D3;\n}\n\n#ncqosnapri .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#ncqosnapri .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#ncqosnapri .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#ncqosnapri .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#ncqosnapri .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#ncqosnapri .gt_sourcenote {\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#ncqosnapri .gt_left {\n  text-align: left;\n}\n\n#ncqosnapri .gt_center {\n  text-align: center;\n}\n\n#ncqosnapri .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#ncqosnapri .gt_font_normal {\n  font-weight: normal;\n}\n\n#ncqosnapri .gt_font_bold {\n  font-weight: bold;\n}\n\n#ncqosnapri .gt_font_italic {\n  font-style: italic;\n}\n\n#ncqosnapri .gt_super {\n  font-size: 65%;\n}\n\n#ncqosnapri .gt_footnote_marks {\n  font-size: 75%;\n  vertical-align: 0.4em;\n  position: initial;\n}\n\n#ncqosnapri .gt_asterisk {\n  font-size: 100%;\n  vertical-align: 0;\n}\n\n#ncqosnapri .gt_indent_1 {\n  text-indent: 5px;\n}\n\n#ncqosnapri .gt_indent_2 {\n  text-indent: 10px;\n}\n\n#ncqosnapri .gt_indent_3 {\n  text-indent: 15px;\n}\n\n#ncqosnapri .gt_indent_4 {\n  text-indent: 20px;\n}\n\n#ncqosnapri .gt_indent_5 {\n  text-indent: 25px;\n}\n</style>\n<table class=\"gt_table\" data-quarto-disable-processing=\"false\" data-quarto-bootstrap=\"false\">\n  <thead>\n    <tr class=\"gt_heading\">\n      <td colspan=\"3\" class=\"gt_heading gt_title gt_font_normal gt_bottom_border\" style><em>Comparison of Copy.Cat and TFT cooperative responses</em></td>\n    </tr>\n    \n    <tr class=\"gt_col_headings\">\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_center\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"&lt;strong&gt;Estimate&lt;/strong&gt;\"><strong>Estimate</strong></th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_center\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"&lt;strong&gt;Difference in estimate&lt;/strong&gt;\"><strong>Difference in estimate</strong></th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_center\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"&lt;strong&gt;p-value&lt;/strong&gt;\"><strong>p-value</strong></th>\n    </tr>\n  </thead>\n  <tbody class=\"gt_table_body\">\n    <tr><td headers=\"vars\" class=\"gt_row gt_center\" style=\"font-family: Ubuntu; color: #000000; background-color: #F9F9F9;\">Median</td>\n<td headers=\"Estimate\" class=\"gt_row gt_center\" style=\"font-family: Ubuntu; color: #000000; background-color: #F9F9F9;\">1.67e-05</td>\n<td headers=\"Sig.\" class=\"gt_row gt_center\" style=\"font-family: Ubuntu; color: #000000; background-color: #F9F9F9;\">0.823</td></tr>\n  </tbody>\n  \n  \n</table>\n</div>\n```\n\n\nDifference in medians\n:::\n:::\n\n\nAxelrod believed that, on average, “nice” algorithms would perform better than “ mean and deceitful” ones like `exact.revenge` and `prober`, and we can clearly see that our most vengeful algorithm performs poorly on the cooperative front, with a mean cooperation of .0055 per game, about once per game. \n\nBased on the algorithm's cooperative response we can then visualize and compute the final score distribution (in total points) for each player after 500 games of 200 rounds each. We'll see that the second player typically scores much higher than player 1 by defecting often and without provocation. However, when player 2 chooses to not betray without provocation or imitate the first's player current choices both players end up with higher and approximately equal scores. Because of this willingness to cooperate, according to Axelrod, the nice algorithms tend to be more conducive to cooperation and less prone to conflict.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Code for data manipulation & plots\"}\ntest2 <- comp.alg(c(exact.revenge, prober), \n                 iter = 500, \n                 rounds = 200, \n                 prob = c(.345, .231), \n                 choice = 0,\n                 default = .10) |> rename(\"R.P1\" = \"A1P1\",\n                                          \"R.P2\" = \"A1P2\",\n                                          \"Pr.P1\" = \"A2P1\",\n                                          \"Pr.P2\" = \"A2P2\")\n\nperf_df <- cbind(test,test2) |> pivot_longer(cols = everything(), \n               names_to = c(\"Algorithm\", \"Player\"),\n               names_pattern = \"([^.]+)\\\\.(P\\\\d)\",\n               values_to = \"Score\") |>\n  mutate(Algorithm = case_when(\n           Algorithm == \"R\" ~ \"Revenge\",\n           Algorithm == \"Pr\" ~ \"Prober\",\n           Algorithm == \"CC\" ~\"Copy.Cat\",\n           Algorithm == \"TFT\" ~ \"Tit×Tat\",\n           TRUE ~Algorithm\n         ),\n         Algorithm = factor(Algorithm),\n         Player = factor(Player)) |>\n  arrange(Algorithm, Player) |>\n  group_by(Algorithm, Player)\n\nstr(perf_df)\n#> gropd_df [4,000 × 3] (S3: grouped_df/tbl_df/tbl/data.frame)\n#>  $ Algorithm: Factor w/ 4 levels \"Copy.Cat\",\"Prober\",..: 1 1 1 1 1 1 1 1 1 1 ...\n#>  $ Player   : Factor w/ 2 levels \"P1\",\"P2\": 1 1 1 1 1 1 1 1 1 1 ...\n#>  $ Score    : num [1:4000] 440 458 432 430 426 432 430 430 438 426 ...\n#>  - attr(*, \"groups\")= tibble [8 × 3] (S3: tbl_df/tbl/data.frame)\n#>   ..$ Algorithm: Factor w/ 4 levels \"Copy.Cat\",\"Prober\",..: 1 1 2 2 3 3 4 4\n#>   ..$ Player   : Factor w/ 2 levels \"P1\",\"P2\": 1 2 1 2 1 2 1 2\n#>   ..$ .rows    : list<int> [1:8] \n#>   .. ..$ : int [1:500] 1 2 3 4 5 6 7 8 9 10 ...\n#>   .. ..$ : int [1:500] 501 502 503 504 505 506 507 508 509 510 ...\n#>   .. ..$ : int [1:500] 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 ...\n#>   .. ..$ : int [1:500] 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 ...\n#>   .. ..$ : int [1:500] 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 ...\n#>   .. ..$ : int [1:500] 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 ...\n#>   .. ..$ : int [1:500] 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 ...\n#>   .. ..$ : int [1:500] 3501 3502 3503 3504 3505 3506 3507 3508 3509 3510 ...\n#>   .. ..@ ptype: int(0) \n#>   ..- attr(*, \".drop\")= logi TRUE\n\n p1 <- ggplot(perf_df, aes(Score, fill= Player)) +\n  geom_density(alpha = .45) +\n  labs(title = NULL,\n       x = NULL,\n       y = NULL) + \n  scale_fill_manual(values = clrs)\n\n \n p2 <- ggplot(perf_df, aes(Score, fill= Algorithm)) +\n  geom_density(alpha = .45) +\n  labs(title = NULL,\n       x = \"Score\",\n       y = NULL) + \n  scale_fill_manual(values = clrs) \n \n#> p1/p2\n  \n```\n:::\n\n::: {.cell layout-align=\"center\" lightbox='true'}\n::: {.cell-output-display}\n![](img/alg_perf2.png){fig-align='center' width=80%}\n:::\n:::\n\n\nThese two plots show the performance of both players and the four algorithms, and we can see that the most extreme results are obtained using the `exact.revenge` algorithm. The density curves for this algorithm are touching the extremes on the left and right, showing that one player will always under perform while the other one, typically the second one, will outperform its opponent. This algorithms is one of the most unreliable ones because player 1 is not able to confidently predict the next moves. Regardless of his choice, after the first betrayal, player 2 will never cooperate again. To my surprise, the `prober` algorithm returned a more favorable score for player 2 than the `tit.for.tat` or the `copy.cat` algorithm; however, the nice algorithms always favored both players, not just player 2. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\n sumperf_gt <- perf_df |> summarise(Score = mean(Score)) |>\n  arrange(Algorithm) |>\n  as_tibble() |> gt() |> \n  tab_header(title = md(\"*Average Player Score by Algorithm*\")) |>\n  cols_label(Algorithm = md(\"**Algorithm**\"),\n             Player = md(\"**Player**\"),\n            Score = md(\"**Score**\")) |>\n  opt_table_font(font = google_font(\"EB Garamond\"),\n                 weight = 400,style = \"plain\", add = TRUE) |>\n  tab_style(style = cell_text(font = google_font(\"Ubuntu\")),\n            locations = cells_body()) |>\n   tab_options(column_labels.font.weight = \"bold\",\n              row_group.font.weight = \"bold\") |>\n  data_color(rows = everything(),\n             palette = \"#f9f9f9\") |>\n  opt_interactive(use_compact_mode = TRUE, use_highlight = TRUE)\n \n sumperf_gt\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"lywlfoadwp\" class=\".gt_table\" style=\"padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n<style>@import url(\"https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap\");\n@import url(\"https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap\");\n#lywlfoadwp table {\n  font-family: 'EB Garamond', system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n#lywlfoadwp thead, #lywlfoadwp tbody, #lywlfoadwp tfoot, #lywlfoadwp tr, #lywlfoadwp td, #lywlfoadwp th {\n  border-style: none;\n}\n\n#lywlfoadwp p {\n  margin: 0;\n  padding: 0;\n}\n\n#lywlfoadwp .gt_table {\n  display: table;\n  border-collapse: collapse;\n  line-height: normal;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: 400;\n  font-style: plain;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#lywlfoadwp .gt_caption {\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n\n#lywlfoadwp .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#lywlfoadwp .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 3px;\n  padding-bottom: 5px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#lywlfoadwp .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#lywlfoadwp .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#lywlfoadwp .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#lywlfoadwp .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: bold;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#lywlfoadwp .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: bold;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#lywlfoadwp .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#lywlfoadwp .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#lywlfoadwp .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#lywlfoadwp .gt_spanner_row {\n  border-bottom-style: hidden;\n}\n\n#lywlfoadwp .gt_group_heading {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: bold;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  text-align: left;\n}\n\n#lywlfoadwp .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: bold;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#lywlfoadwp .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#lywlfoadwp .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#lywlfoadwp .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#lywlfoadwp .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#lywlfoadwp .gt_stub_row_group {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n  vertical-align: top;\n}\n\n#lywlfoadwp .gt_row_group_first td {\n  border-top-width: 2px;\n}\n\n#lywlfoadwp .gt_row_group_first th {\n  border-top-width: 2px;\n}\n\n#lywlfoadwp .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#lywlfoadwp .gt_first_summary_row {\n  border-top-style: solid;\n  border-top-color: #D3D3D3;\n}\n\n#lywlfoadwp .gt_first_summary_row.thick {\n  border-top-width: 2px;\n}\n\n#lywlfoadwp .gt_last_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#lywlfoadwp .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#lywlfoadwp .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#lywlfoadwp .gt_last_grand_summary_row_top {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: double;\n  border-bottom-width: 6px;\n  border-bottom-color: #D3D3D3;\n}\n\n#lywlfoadwp .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#lywlfoadwp .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#lywlfoadwp .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#lywlfoadwp .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#lywlfoadwp .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#lywlfoadwp .gt_sourcenote {\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#lywlfoadwp .gt_left {\n  text-align: left;\n}\n\n#lywlfoadwp .gt_center {\n  text-align: center;\n}\n\n#lywlfoadwp .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#lywlfoadwp .gt_font_normal {\n  font-weight: normal;\n}\n\n#lywlfoadwp .gt_font_bold {\n  font-weight: bold;\n}\n\n#lywlfoadwp .gt_font_italic {\n  font-style: italic;\n}\n\n#lywlfoadwp .gt_super {\n  font-size: 65%;\n}\n\n#lywlfoadwp .gt_footnote_marks {\n  font-size: 75%;\n  vertical-align: 0.4em;\n  position: initial;\n}\n\n#lywlfoadwp .gt_asterisk {\n  font-size: 100%;\n  vertical-align: 0;\n}\n\n#lywlfoadwp .gt_indent_1 {\n  text-indent: 5px;\n}\n\n#lywlfoadwp .gt_indent_2 {\n  text-indent: 10px;\n}\n\n#lywlfoadwp .gt_indent_3 {\n  text-indent: 15px;\n}\n\n#lywlfoadwp .gt_indent_4 {\n  text-indent: 20px;\n}\n\n#lywlfoadwp .gt_indent_5 {\n  text-indent: 25px;\n}\n</style>\n<div style=\"font-family:&#39;EB Garamond&#39;, system-ui, &#39;Segoe UI&#39;, Roboto, Helvetica, Arial, sans-serif;border-top-style:solid;border-top-width:2px;border-top-color:#D3D3D3;\">\n<div class=\"gt_heading gt_title gt_font_normal\" style=\"text-size:bigger;\"><em>Average Player Score by Algorithm</em></div>\n<div class=\"gt_heading gt_subtitle \"></div>\n</div>\n<div id=\"lywlfoadwp\" class=\"reactable html-widget\" style=\"width:auto;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"lywlfoadwp\">{\"x\":{\"tag\":{\"name\":\"Reactable\",\"attribs\":{\"data\":{\"Algorithm\":[\"Copy.Cat\",\"Copy.Cat\",\"Prober\",\"Prober\",\"Revenge\",\"Revenge\",\"Tit×Tat\",\"Tit×Tat\"],\"Player\":[\"P1\",\"P2\",\"P1\",\"P2\",\"P1\",\"P2\",\"P1\",\"P2\"],\"Score\":[441.352,441.352,476.494,511.994,362.354,756.764,489.282,486.282]},\"columns\":[{\"id\":\"Algorithm\",\"name\":\"<strong>Algorithm<\\/strong>\",\"type\":\"factor\",\"style\":\"function(rowInfo, colInfo) {\\nconst rowIndex = rowInfo.index + 1\\nif (colInfo.id === 'Algorithm' & rowIndex === 1) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Algorithm' & rowIndex === 2) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Algorithm' & rowIndex === 3) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Algorithm' & rowIndex === 4) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Algorithm' & rowIndex === 5) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Algorithm' & rowIndex === 6) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Algorithm' & rowIndex === 7) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Algorithm' & rowIndex === 8) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 1) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 2) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 3) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 4) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 5) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 6) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 7) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 8) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 1) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 2) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 3) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 4) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 5) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 6) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 7) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 8) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\n}\",\"cell\":[\"Copy.Cat\",\"Copy.Cat\",\"Prober\",\"Prober\",\"Revenge\",\"Revenge\",\"Tit×Tat\",\"Tit×Tat\"],\"html\":true,\"align\":\"center\",\"headerStyle\":{\"font-weight\":\"normal\"}},{\"id\":\"Player\",\"name\":\"<strong>Player<\\/strong>\",\"type\":\"factor\",\"style\":\"function(rowInfo, colInfo) {\\nconst rowIndex = rowInfo.index + 1\\nif (colInfo.id === 'Algorithm' & rowIndex === 1) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Algorithm' & rowIndex === 2) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Algorithm' & rowIndex === 3) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Algorithm' & rowIndex === 4) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Algorithm' & rowIndex === 5) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Algorithm' & rowIndex === 6) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Algorithm' & rowIndex === 7) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Algorithm' & rowIndex === 8) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 1) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 2) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 3) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 4) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 5) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 6) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 7) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 8) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 1) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 2) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 3) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 4) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 5) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 6) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 7) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 8) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\n}\",\"cell\":[\"P1\",\"P2\",\"P1\",\"P2\",\"P1\",\"P2\",\"P1\",\"P2\"],\"html\":true,\"align\":\"center\",\"headerStyle\":{\"font-weight\":\"normal\"}},{\"id\":\"Score\",\"name\":\"<strong>Score<\\/strong>\",\"type\":\"numeric\",\"style\":\"function(rowInfo, colInfo) {\\nconst rowIndex = rowInfo.index + 1\\nif (colInfo.id === 'Algorithm' & rowIndex === 1) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Algorithm' & rowIndex === 2) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Algorithm' & rowIndex === 3) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Algorithm' & rowIndex === 4) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Algorithm' & rowIndex === 5) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Algorithm' & rowIndex === 6) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Algorithm' & rowIndex === 7) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Algorithm' & rowIndex === 8) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 1) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 2) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 3) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 4) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 5) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 6) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 7) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Player' & rowIndex === 8) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 1) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 2) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 3) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 4) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 5) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 6) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 7) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\nif (colInfo.id === 'Score' & rowIndex === 8) {\\n  return { fontFamily: 'Ubuntu', color: '#000000', backgroundColor: '#F9F9F9' }\\n}\\n\\n}\",\"cell\":[\"441\",\"441\",\"476\",\"512\",\"362\",\"757\",\"489\",\"486\"],\"html\":true,\"align\":\"right\",\"headerStyle\":{\"font-weight\":\"normal\"}}],\"defaultPageSize\":10,\"showPageSizeOptions\":false,\"pageSizeOptions\":[10,25,50,100],\"paginationType\":\"numbers\",\"showPagination\":true,\"showPageInfo\":true,\"minRows\":1,\"highlight\":true,\"compact\":true,\"showSortable\":true,\"height\":\"auto\",\"theme\":{\"color\":\"#333333\",\"backgroundColor\":\"#FFFFFF\",\"stripedColor\":\"rgba(128,128,128,0.05)\",\"style\":{\"fontFamily\":\"'EB Garamond', system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif\"},\"headerStyle\":{\"borderTopStyle\":\"solid\",\"borderTopWidth\":\"2px\",\"borderTopColor\":\"#D3D3D3\",\"borderBottomStyle\":\"solid\",\"borderBottomWidth\":\"2px\",\"borderBottomColor\":\"#D3D3D3\"}},\"elementId\":\"lywlfoadwp\",\"dataKey\":\"52a2bedf15bb4849c5d08c94bc1671f4\"},\"children\":[]},\"class\":\"reactR_markup\"},\"evals\":[\"tag.attribs.columns.0.style\",\"tag.attribs.columns.1.style\",\"tag.attribs.columns.2.style\"],\"jsHooks\":[]}</script>\n</div>\n```\n\n:::\n:::\n\n\nNevertheless, regardless of which algorithm we used, player 1's score is, on average, lower than player 2, even if the nice algorithms tend to equalize the scores and may result in less conflict as Axelrod described. \n\n### practical implications\n\nAmong all the algorithms submitted to Axelrod, the top performer was Tit–for–tat because it was “nice”. Algorithms that always betrayed or were “sneaky” were more likely to end up in a state of conflict. Our custom algorithms also showed this behavior, both players thrived when cooperation was a priority for one of the players. In our case, the `tit.for.tat` algorithm outperformed others in this regard even if it didn't achieve the maximum number of points like the `exact.revenge` algorithm. \n\nHere are the rules for strategic cooperation:\n\n-   Avoid unnecessary conflict by cooperating as long as your opponent does.\n-   If your opponent betrays you without provocation— respond in kind…once.\n-   Then forgive the betrayal, and cooperate again.\n-   Be clear and predictable so your opponent knows how you act and can plan accordingly.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../../../site_libs/core-js-2.5.3/shim.min.js\"></script>\n<script src=\"../../../../site_libs/react-18.2.0/react.min.js\"></script>\n<script src=\"../../../../site_libs/react-18.2.0/react-dom.min.js\"></script>\n<script src=\"../../../../site_libs/reactwidget-2.0.0/react-tools.umd.cjs\"></script>\n<script src=\"../../../../site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<link href=\"../../../../site_libs/reactable-0.4.4/reactable.css\" rel=\"stylesheet\" />\n<script src=\"../../../../site_libs/reactable-binding-0.4.4/reactable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}