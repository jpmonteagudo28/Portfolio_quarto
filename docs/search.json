[
  {
    "objectID": "uses/index.html",
    "href": "uses/index.html",
    "title": "What I use",
    "section": "",
    "text": "I’ve gradually discovered a research workflow that suits my needs (and my budget😅) and maximizes productivity.\nI’m leaving a list of the programs/software I regularly use as a way to track the changes to my workflow and also provide guidance to those looking for free resources to increase their efficiency and organization."
  },
  {
    "objectID": "uses/index.html#discovery-and-idea-generation",
    "href": "uses/index.html#discovery-and-idea-generation",
    "title": "What I use",
    "section": "Discovery and Idea Generation",
    "text": "Discovery and Idea Generation\nWriting\n\nI use Joplin– an open-source note-taking app with a markdown editor and customizable plugins. Another great option is Obsidian which includes knowledge graphs to organize your thoughts.\nI use Typora to create stand-alone markdown files. Typora also supports pandoc-flavored markdown which makes it easier to transform markdown to other formats like .docx, .pdf, etc.\nI use a good ol’ Mead Five Star Spiral Fat Lil’ Pocket Notebook for note-taking (books I read, ideas, summaries, schedules, to-do lists). I’ve tried planners, calendars, apps and none of those things seem to keep me on track as brilliantly as a handwritten note in one of those fat little notebooks.\nI use Mendeley as my bibliography and citation manager. The free plan includes 2GB of storage, which is more than I need. I store my bibliographies in Bibtex format.\nI use Overleaf and Detexify which makes finding LateX symbols a breeze. Just draw the symbol you’re looking for and the site provides a list of possible matches with their LateX syntax.\nI use Natural Speech Reader to help with text editing."
  },
  {
    "objectID": "uses/index.html#data-collection-and-analysis",
    "href": "uses/index.html#data-collection-and-analysis",
    "title": "What I use",
    "section": "Data Collection and Analysis",
    "text": "Data Collection and Analysis\nScience and Research\n\nI currently use R and RStudio for my data analysis and graphing needs, and VSCode for everything else.\nI used G-Power and piface for sample size calculations, but their utility decreased as I began to use more complicated models.\nMy main statistical programming software was SPSS until 2020, but its lackluster versatility left me disappointed. I especially didn’t like all the clicking and the way their syntax, output, and data panels were set up. Unfortunately, that’s the software of choice in many universities in the U.S., including mine.\nI also use Notepad ++, a text editor that supports more than two dozen programming languages (not markdown). I sometimes use it alongside VSCode.\nI use Github and Git Bash to store almost everything I write and for version control."
  },
  {
    "objectID": "uses/index.html#publication",
    "href": "uses/index.html#publication",
    "title": "What I use",
    "section": "Publication",
    "text": "Publication\nGraphic Design\n\nI’ve used Canva for every design in this website and personal documents. I also have free access to Adobe InDesign but haven’t used it much.\nI totally recommend Practical Typography, by Matthew Butterick– a typograhpy primer for the graphic designer and the layperson trying to create beautiful documents.\nI have been learning Pollen, a markup language used to create beautiful digital books.\nI use PowerPoint to create simple and stunning presentations. I have free access to Microsoft products, and it’s also the best slide editor I’ve seen.\nI use Google Fonts API for font selection and David Jonathan Ross’ typefaces. My preferred fonts are Arsenal, ETBembo, EB Garamond, Warbler, Livory, Charter, and Cooper Hewitt.\nProductivity\n\nI use Dropbox and Google One for file storage and backup. I get Dropbox for free through my school, and I pay for a family Google One subscription. However, both services cost about the same and offer similar storage space (3TB and 2TB respectively).\nI use the Windows Clock app focus feature to track my time. I’m not easily distracted if I’m working towards a concrete, timed goal so scheduling times of intense mental activity is a huge help.\nI use Otter.ai as my audio recording and automatic transcription service. I record presentations, interviews, talks, etc. and Otter.ai produces a solid transcript that I can then save or use in content creation.\nI use Chat GPT to answer all sorts of questions and to guide me in the creative process."
  },
  {
    "objectID": "uses/index.html#hardware",
    "href": "uses/index.html#hardware",
    "title": "What I use",
    "section": "Hardware",
    "text": "Hardware\n\nI use Yubico and Keybase for privacy and security.\nI use a 2020 15.6″ i5Core Dell, a 2020 13″ MacBook Pro, and an iPhone 13 mini."
  },
  {
    "objectID": "uses/index.html#guides",
    "href": "uses/index.html#guides",
    "title": "What I use",
    "section": "Guides",
    "text": "Guides\n\n\nGood enough practices in scientific computing detail the process of organizing, structuring, and sharing data and research with collaborators while keeping track of all the changes.\n\nFour steps to an applied micro paper, by Jesse Shapiro, outlines the process of writing an academic paper in the applied sciences. It’s a very succinct guide to help students and researchers improve their writing.\n\nHow to give an applied micro talk, also by Jesse Shapiro, is a brief explanation of why your presentations should be short and engaging, not so tediously structured and technical.\n\nPublic speaking for academic economists, by Rachel Meager, provides a simple and witty guide to public speaking for researchers and academics.\n\nThe Plain Person’s Guide to Plain Text Social Science. A useful primer on organizing and structuring your writing and research process in the Social Science sphere. It provides a template for research and writing that you can transform to suit your needs and budget (I mostly use free software except for Typora and Google One).\nKieran Healy’s Making Slides guide to creating engaging slides by using layers, highlighting, and repetition to build your argument."
  },
  {
    "objectID": "research/articles/index.html",
    "href": "research/articles/index.html",
    "title": "On the Surgical Removal of Cardassian Cranial Implants: A case study of a Cardassian patient",
    "section": "",
    "text": "Paper (preprint)\nStatistical analysis notebook\nGitHub repository"
  },
  {
    "objectID": "research/articles/index.html#important-links",
    "href": "research/articles/index.html#important-links",
    "title": "On the Surgical Removal of Cardassian Cranial Implants: A case study of a Cardassian patient",
    "section": "",
    "text": "Paper (preprint)\nStatistical analysis notebook\nGitHub repository"
  },
  {
    "objectID": "research/articles/index.html#abstract",
    "href": "research/articles/index.html#abstract",
    "title": "On the Surgical Removal of Cardassian Cranial Implants: A case study of a Cardassian patient",
    "section": "Abstract",
    "text": "Abstract\nI have reset the sensors to scan for frequencies outside the usual range. By emitting harmonic vibrations to shatter the lattices. We will monitor and adjust the frequency of the resonators. He has this ability of instantly interpreting and extrapolating any verbal communication he hears. It may be due to the envelope over the structure, causing hydrogen-carbon helix patterns throughout. I’m comparing the molecular integrity of that bubble against our phasers."
  },
  {
    "objectID": "research/articles/index.html#important-notes",
    "href": "research/articles/index.html#important-notes",
    "title": "On the Surgical Removal of Cardassian Cranial Implants: A case study of a Cardassian patient",
    "section": "Important notes",
    "text": "Important notes\nStellar flares are increasing in magnitude and frequency. Set course for Rhomboid Dronegar 006, warp seven. There’s no evidence of an advanced communication network. Total guidance system failure, with less than 24 hours’ reserve power. Shield effectiveness has been reduced 12 percent. We have covered the area in a spherical pattern which a ship without warp drive could cross in the given time.\nResistance is futile."
  },
  {
    "objectID": "research/articles/index.html#citation",
    "href": "research/articles/index.html#citation",
    "title": "On the Surgical Removal of Cardassian Cranial Implants: A case study of a Cardassian patient",
    "section": "Citation",
    "text": "Citation\n\n Add to Mendeley \n\n@article{BashirGarak:2178,\n    Author = {Julian Bashier and Elim Garak},\n    Journal = {Starbase Deep Space Nine},\n    Month = {9},\n    Number = {9},\n    Pages = {1425--1439},\n    Title = {On the Surgical Removal of Cardassian Cranial Implants: A case study of a Cardassian patient},\n    Volume = {130},\n    Year = {2178}}"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "JP Monteagudo",
    "section": "",
    "text": "Hi, my name is JP.\n\n\nI’m passionate about human health, statistics, code, data and design. This website is a collection of projects, research, and discussions on topics that I find interesting and meaningful. My goal is to make this site a source of publicly available data, code and insights that can be used by others to advance their learning journey.\n\nLearn more about me →"
  },
  {
    "objectID": "blog/index.html#section",
    "href": "blog/index.html#section",
    "title": "Blog",
    "section": "2024",
    "text": "2024\n\n\n    \n    \n                  \n            Apr 19, 2024\n        \n        \n            Animating the Datasaurus dataset as part of the 30 Day Chart Challenge\n\n            \n\n            Dinosaurs and correlation coefficients\n            \n            \n            10.59350/wx5k1-ajc38\n            \n        \n        \n    \n    \n    \n                  \n            Apr 15, 2024\n        \n        \n            Beautiful movement—the music and beauty of Lissajous(Liss–uh–joo) curves\n\n            \n\n            Simple graphical and mathematical exploration of Lissajous curves \n            \n            \n            10.59350/y9kmp-zqh66\n            \n        \n        \n    \n    \n    \n                  \n            Mar 17, 2024\n        \n        \n            Don't be an absolutist. Use the here package for reproducible workflows\n\n            \n\n            Gentle reminders when using the `here` package for your `RStudio` projects\n            \n            \n            10.59350/4a9fr-acc34\n            \n        \n        \n    \n    \n\n\nNo matching items"
  },
  {
    "objectID": "blog/2024/04/lissajous/index.html",
    "href": "blog/2024/04/lissajous/index.html",
    "title": "Beautiful movement—the music and beauty of Lissajous(Liss–uh–joo) curves",
    "section": "",
    "text": "Lissajous curves are created by plotting two oscillations on perpendicular axes \\(x\\) and \\(y\\)​​​. These oscillations, represented by sinusoidal functions, intersect to create different patterns. When the ratio of these frequencies is equal to \\(1\\)— the oscillations are equally phased— the curve is a straight line. When the frequencies on both axes differ, the oscillations are out of phase—one moves faster than the other at a specific angle—and our Lissajous figure will show a curve. Each frequency produces a specific musical note that will intercept and either form a pleasant sound, harmonious consonance or discordance. Consonant notes have a perfect ratio."
  },
  {
    "objectID": "blog/2024/04/lissajous/index.html#lissajous-curves",
    "href": "blog/2024/04/lissajous/index.html#lissajous-curves",
    "title": "Beautiful movement—the music and beauty of Lissajous(Liss–uh–joo) curves",
    "section": "",
    "text": "Lissajous curves are created by plotting two oscillations on perpendicular axes \\(x\\) and \\(y\\)​​​. These oscillations, represented by sinusoidal functions, intersect to create different patterns. When the ratio of these frequencies is equal to \\(1\\)— the oscillations are equally phased— the curve is a straight line. When the frequencies on both axes differ, the oscillations are out of phase—one moves faster than the other at a specific angle—and our Lissajous figure will show a curve. Each frequency produces a specific musical note that will intercept and either form a pleasant sound, harmonious consonance or discordance. Consonant notes have a perfect ratio."
  },
  {
    "objectID": "blog/2024/04/lissajous/index.html#music-perfect-ratios",
    "href": "blog/2024/04/lissajous/index.html#music-perfect-ratios",
    "title": "Beautiful movement—the music and beauty of Lissajous(Liss–uh–joo) curves",
    "section": "Music & Perfect Ratios",
    "text": "Music & Perfect Ratios\nThink of a guitar string vibrating at a base frequency of \\(329 Hz\\)—\\(329\\) cycles per second. By altering our position along the string, we change the frequency and thus produce different notes. If we moved from the nut (fret \\(0\\)) to between frets \\(11\\) and \\(12\\) and plucked the string, the frequency would now be twice as high—we call this an octave. If we moved \\(3/4\\) down from the nut, our new note would oscillate at three times the frequency of E4(\\(329Hz\\)). We can produce an infinite amount of notes by moving along the string and altering the speed of the oscillations. You are creating music with movement!\nTheory of Just Intonation\nHowever, keeping track of an infinite, unordered sequence of notes is impossible; instead, we use systems that allow us to measure and obtain the frequency of a small number of notes. One such system is called “just intonation” and a commonly seen tuning method is 5-limit tuning. This method allows us to find the exact, pure frequency of other notes by multiplying our base frequency by products of the power of prime numbers \\(2\\), \\(3\\), and \\(5\\) (e.g., \\(2^{-1} \\cdot 3^{1} \\cdot 5^{1}\\)).1\n1 In 5–limit tuning we only multiply integers to obtain other musical notes.2 octaves: \\(f_{x} = 2^{k}\\); perfect fifths: \\(3^{k}\\), major thirds: \\(5^{k},k \\in \\mathbb{Z}\\).3 Sometimes the resulting note is outside our octave, and we simply divide it by two and bring it back to our interval.      We call the sinusoidal movements in intervals of powers of \\(2\\) – octaves, powers of \\(3\\) represent perfect fifths, and powers of \\(5\\) are called major thirds2. By multiplying our base frequency by different combinations of these powers,3 we get sets of harmoniously consonant and discordant notes.\nThe Perfect ratios\nSo how can we make sure every note is consonant? Thankfully, the ancient Greeks discovered a way to create beautifully sounding and naturally occurring notes using perfect4 ratios for octaves, major fifths, and major thirds. These perfect ratios make music blend, flow, and feel “right”. These are the ratios that create all of the Lissajous figures we’ll explore today.\n4 perfect refers to ratios that produce “just” or “pure” melodic sounds.\nCoderatios &lt;- c(1,\"9/8\", \"5/4\",\"4/3\",\"3/2\", \"5/3\",\"15/8\",2,240,270,300,320,360,400,450,480)\ncols &lt;- c(\"C\",\"D\",\"E\",\"F\",\"G\",\"A\",\"B\",\"C'\")\nrows &lt;- c(\"Perfect Ratios\", \"Frequency(in Hz)\")\nperfect_ratios &lt;- matrix(ratios, ncol = 8, byrow = TRUE)\ncolnames(perfect_ratios) &lt;- cols\nrownames(perfect_ratios) &lt;- rows\nperfect_ratios\n##                  C     D     E     F     G     A     B      C'   \n## Perfect Ratios   \"1\"   \"9/8\" \"5/4\" \"4/3\" \"3/2\" \"5/3\" \"15/8\" \"2\"  \n## Frequency(in Hz) \"240\" \"270\" \"300\" \"320\" \"360\" \"400\" \"450\"  \"480\"\nknitr::kable(perfect_ratios)\n\n\nPerfect ratios in Just Intonation using 5-limit tuning method\n\n\nC\nD\nE\nF\nG\nA\nB\nC’\n\n\n\nPerfect Ratios\n1\n9/8\n5/4\n4/3\n3/2\n5/3\n15/8\n2\n\n\nFrequency(in Hz)\n240\n270\n300\n320\n360\n400\n450\n480"
  },
  {
    "objectID": "blog/2024/04/lissajous/index.html#the-code-animation",
    "href": "blog/2024/04/lissajous/index.html#the-code-animation",
    "title": "Beautiful movement—the music and beauty of Lissajous(Liss–uh–joo) curves",
    "section": "The Code & Animation",
    "text": "The Code & Animation\nWe’ll create the Lissajous curves using two sinusoidal waves on different phases 5. The numerator of the perfect ratio will be the coefficient \\(a\\) of the \\(sin\\) function, \\(sin(t) = sin(at + \\delta)\\), and the denominator \\(b\\) will go to the \\(y\\) coordinate \\(sin(t) = sin(bt)\\). We’ll define our interval from \\(0\\) to \\(2\\pi\\).​​\n5 the curves can also be created with \\(sin(t)\\) and \\(cos(t)\\) functions since \\(cos(t) = sin(t + \\frac{\\pi}{2})\\), but the phase difference will now be \\(\\frac{a}{b}*\\frac{\\pi}{2}\\).\n\n\n\n\n\nHelpful Tip\n\n\n\nYou can familiarize yourself with Lissajous figures and their sine functions by using this interactive virtual oscilloscope.\n\n\n    Using the gganimate package in RStudio, we’ll build a data frame with a set number of times steps between \\(0\\) and \\(2\\pi\\)​; and the figures with coordinates for each perfect ratio. Then, we’ll stitch each plot with the time steps and coordinates to get a final \\(8 × 8\\) animated plot.\n\nCode## ------------------------------- ##\n## Creating Lissajous figures      ##\n## ------------------------------- ##\nlibrary(gganimate)# Loading libs   ##\nlibrary(tidyverse)                 ##\nlibrary(here)                      ##\nlibrary(av)                        ##\n## ------------------------------- ##\n\nparams &lt;- data.frame(\n  id &lt;- seq(1,500,1), # no. of steps\n  t &lt;- seq(0,2*pi, length.out = 500)  # equally spaced intervals 0-2*pi\n)\n\nfigs &lt;- function(t){\n  x1 &lt;- sin(t*1) # We're only using perfect ratios\n  y1 &lt;- sin(t*1)\n  \n  x2 &lt;- sin(t*9)\n  y2 &lt;- sin(t*8)\n  \n  x3 &lt;- sin(t*5)\n  y3 &lt;- sin(t*4)\n  \n  x4 &lt;- sin(t*4)\n  y4 &lt;- sin(t*3)\n  \n  x5 &lt;- sin(t*3)\n  y5 &lt;- sin(t*2)\n  \n  x6 &lt;- sin(t*5)\n  y6 &lt;- sin(t*3)\n  \n  x7 &lt;- sin(t*15)\n  y7 &lt;-  sin(t*8)\n  \n  x8 &lt;- sin(t*2)\n  y8 &lt;- sin(t*1)\n  \n  time &lt;- seq_along(t)\n  \n  data.frame( # Create df with x, y variables accross time\n    time, \n    x1, x2, x3, x4, x5, x6, x7, x8,\n    y1, y2, y3, y4, y5, y6, y7, y8\n  )\n}\n\nactual_figs &lt;- figs(params$t)\n\ndf &lt;- bind_cols(params, actual_figs) |&gt; # bind two dfs\n  select(everything()) |&gt; # make data long\n  pivot_longer(x1:x8, names_to = \"x_group\", values_to = \"x\") |&gt;\n  pivot_longer(y1:y8, names_to = \"y_group\", values_to = \"y\") |&gt;\n  mutate(x_group = str_remove(x_group, \"x\"),\n         y_group = str_remove(y_group, \"y\")) |&gt;\n  unite(\"group_id\", x_group, y_group, remove = FALSE)\n\nplot &lt;- df|&gt;\n  ggplot(aes(x = x, y = y, color = group_id, group = group_id)) +\n  geom_point(size = 3) +\n  geom_path() +\n  facet_grid(x_group ~ y_group) +\n  coord_equal() +\n  guides(color = \"none\") +\n  theme_void() +\n  transition_reveal(time) +\n  ease_aes(\"linear\")\n\nanimate(plot, duration = 30, fps = 24, height = 1080, width = 1080,\n        renderer = av_renderer())\n\nanim_save(filename = \"lissajous_figs.mp4\",\n          path = here::here(\"blog\",\"2024\",\"04\",\"lissajous\",\"documents\"),\n          height = 1080, width = 1080)\n#| Code adapted from Kieran Healy's blog \"Pi Day Circles\""
  },
  {
    "objectID": "blog/2024/04/lissajous/index.html#the-final-product",
    "href": "blog/2024/04/lissajous/index.html#the-final-product",
    "title": "Beautiful movement—the music and beauty of Lissajous(Liss–uh–joo) curves",
    "section": "The Final Product",
    "text": "The Final Product\nHere’s the final, animated \\(8×8\\) plot displaying Lissajous figures using only the perfect ratios."
  },
  {
    "objectID": "blog/2024/03/here/index.html",
    "href": "blog/2024/03/here/index.html",
    "title": "Don’t be an absolutist. Use the here package for reproducible workflows",
    "section": "",
    "text": "Don’t be an absolutist– use relative paths. Use the here package instead of setwd() or getwd() to increase reproducibility and avoid wasting your and other people’s time."
  },
  {
    "objectID": "blog/2024/03/here/index.html#tldr",
    "href": "blog/2024/03/here/index.html#tldr",
    "title": "Don’t be an absolutist. Use the here package for reproducible workflows",
    "section": "",
    "text": "Don’t be an absolutist– use relative paths. Use the here package instead of setwd() or getwd() to increase reproducibility and avoid wasting your and other people’s time."
  },
  {
    "objectID": "blog/2024/03/here/index.html#whats-the-problem-with-setwd",
    "href": "blog/2024/03/here/index.html#whats-the-problem-with-setwd",
    "title": "Don’t be an absolutist. Use the here package for reproducible workflows",
    "section": "What’s the problem with setwd()?",
    "text": "What’s the problem with setwd()?\nSince I created this website, I’ve been coding, writing, and reading a lot more which has unequivocally led to a mountain of new files and the forging of new paths– quite literally. At first, I kept things pretty organized, but now it’s nearly impossible to know where I saved such_and_such.txt file without wasting at least 5 minutes of my day.\nThis is what I used to do:\n\nurl1 &lt;- \"https://somefile_online_data_source_here.com\"\ndownload.file(url1, destfile = \"./data_file_here.zip\")\nunzip(\"data_file_here.zip\", exdir = getwd())\nDat &lt;- readRDS(\"summaryDat.rds\")\nDat2 &lt;- readRDS(\"SummaryDat2.rds\")\n\nMy directory will be anywhere on my device unless I have previously specified it using setwd(), but this strategy will soon be an obstacle to saving new information in an organized and reproducible way. If, later on, I change my R scripts to a different folder the original file path won’t work anymore."
  },
  {
    "objectID": "blog/2024/03/here/index.html#here-is-the-solution",
    "href": "blog/2024/03/here/index.html#here-is-the-solution",
    "title": "Don’t be an absolutist. Use the here package for reproducible workflows",
    "section": "\nhere is the solution 📁",
    "text": "here is the solution 📁\nThe here package allows you to set up a relative path mapped onto your R project directory on every device regardless of your absolute path.\nThe here function\nSuppose my directory is located in the Project folder. The here package is going to look for the .Rproj file and establish the root directory there.\n\n# Project/\n#    |\n#    |__ data/\n#    |    |___  summaryDat.rds\n#    |    |___  summaryDat2.rds\n#    |\n#    |__ blog/\n#    |    |_____index.qmd\n#    |    |\n#    |    |__ post/\n#    |    | |______ 2024/\n#    |    |       |____ 02/\n#    |    |          |____  index.qmd\n#    |    |              |____  dat3.R\n#    |    |__ img/\n#    |      |_____  plots.png\n#    |\n#    |__ scripts/\n#      |____ ind.R\n#      |____ cond.R\n\nHere you can see my root directory and how that changes with each iteration of the here command.\n\nlibrary(here)\nhere::here()\n# [1] \"C:/Users/jpmonteagudo/Desktop/R/Project\"\n  here::here(\"blog\")\n# [1] \"C:/Users/jpmonteagudo/Desktop/R/Project/blog\"\n  here::here(\"scripts\")\n# [1] \"C:/Users/jpmonteagudo/Desktop/R/Project/scripts\"\n# I'll point R to the actual document by providing the full relative path\nhere::here(\"blog\",\"post\",\"2024\",\"02\",\"dat3.R\")\n# [1] \"C:/Users/jpmonteagudo/Desktop/R/Project/blog/post/2024/02/dat3.R\"\n\nI can also go up several folders at once by using the full relative path. However, when I call the here function again, it sends me back to my root directory.\n\nhere::here()\n# [1] \"C:/Users/jpmonteagudo/Desktop/R/Project\"\n\nI would use the here function to get or write files and not just be there. If I don’t need anything from my subdirectory, then R will go back to its root, the .Rproj. For example, saving a .png file with multiple plots involves specifying the relative path using here::here().\n\n\n## Using ggplot2 to save my plots\n\nggsave(\"plots.png\",arranged_plots, \n       path = here::here(\"blog\",\"2024\",\"02\",\"post\",\"img\"),\n                width = 800,\n                height = 600,\n                units = \"px\",\n                dpi = 72)\n\n## The same can be done using base R\n\ndev.copy(png,here::here(\"blog\",\"2024\",\"02\",\"clt\",\"img\",\"plots.png\"), width = 800, height = 600)\ndev.off()\n\nThe set_here function\nIf I want to “just be somewhere” anytime I open my project, I would use another function– the set_here function. Basically, this function creates a .here file anywhere in your project so you can use this directory as your root. Here’s the description in the function’s syntax\n\nWhen here encounters such a file, it uses the directory that contains this file as root. This is useful if none of the default criteria apply. You need to restart the R session so that here() picks up the newly created file.\n\n\nhere::set_here(\"blog/2024\")\n# Created file .here in C:\\Users\\jpmonteagudo\\Desktop\\R\\Project\\blog\\2024. \n# Please start a new R session in the new project directory.\n\nNext, I start a new R session here, and RStudio will automatically set my directory to this folder. I don’t need to open the R project to reach this new directory. It will give me access to the folder’s files, and I can then set a relative path to other files.\n\n# Checking directory in new R session\nhere::here()\n# [1] \"C:/Users/jpmonteagudo/Desktop/R/Project/blog/2024\"\n\nFrom this new directory, I can reach files anywhere by using the here::here() function.\nThe confusing i_am function\nThis function has given me a headache. The here package is supposed to be a tool that facilitates collaboration and connectivity, but I just couldn’t get it to work until now.\nCall the here::i_am() function at the top of your script in the first chunk of your markdown file. It will accept a relative path and then establish the new project root there. So far, it only works when I point R to a specific file I’d like to work with. If I choose a file path that’s not in my project directory, it will just point to the original directory and throw an error. If the current directory is outside of the project where the current script is running, you’ll get an error message: Could not find associated project in working directory or any parent directory.\n\n# You're in the scripts folder working on ind.R but need to access summaryDat2.rds.\n#  Simply include the relative path to the data file at the top of your script:\nlibrary(readr)\ndata &lt;- read_csv(here::i_am(\"data/summaryDat2.rds\"))\n# From my script I'm now pointing to a folder containing my Dat2.R\n\nThe dr_here function\nThe here::dr_here() shows a default message explaining why the current directory was chosen. You probably won’t use this function often– unless you’re curious and want to understand how the package selects the root directory. However, if you used here::here(\"file_path\") and got an unexpected result, go ahead and call here::dr_here. It’ll most likely ask you to create a .here file or set your directory using the here::i_am() function.\nIn the end, the here package will make it easy to collaborate and work on your projects on any device by using the here::i_am(), here::here(), and here::set_here() functions."
  },
  {
    "objectID": "about/index.html",
    "href": "about/index.html",
    "title": "jp monteagudo",
    "section": "",
    "text": "Hello there,\n\nThanks for stopping by!\nI’m an aspiring epidemiologist currently pursuing post-graduate studies in Epidemiology at Liberty University. I’m interested in clinical epidemiology, epidemiological research methods, infectious diseases, pharmaco-epidemiology and nutritional epidemiology.\nI love statistics and the R programming language. I’m currently taking a deep dive into generalized linear models, causal inference and data visualization.\nNowadays, I work as a Learning & Development Specialist conducting a pilot study analyzing the impact of new hire training on performance in a fast-paced contact center environment."
  },
  {
    "objectID": "blog/2024/04/dinosaurs/index.html",
    "href": "blog/2024/04/dinosaurs/index.html",
    "title": "Animating the Datasaurus dataset as part of the 30 Day Chart Challenge",
    "section": "",
    "text": "The 30DayChartChallenge is a data visualization community that hosts daily challenges for April. Today’s challenge involves dinosaurs. I used the Datasaurus package to create an animated visualization to demonstrate the importance of graphing data, and the effects of outliers on statistical properties. In these datasets, the mean and the standard deviation of \\(x\\) and \\(y\\) remain almost the same, but the distribution of observation pairs goes through obvious drastic changes."
  },
  {
    "objectID": "blog/2024/04/dinosaurs/index.html#visualization-pearsons-correlation-coefficient",
    "href": "blog/2024/04/dinosaurs/index.html#visualization-pearsons-correlation-coefficient",
    "title": "Animating the Datasaurus dataset as part of the 30 Day Chart Challenge",
    "section": "",
    "text": "The 30DayChartChallenge is a data visualization community that hosts daily challenges for April. Today’s challenge involves dinosaurs. I used the Datasaurus package to create an animated visualization to demonstrate the importance of graphing data, and the effects of outliers on statistical properties. In these datasets, the mean and the standard deviation of \\(x\\) and \\(y\\) remain almost the same, but the distribution of observation pairs goes through obvious drastic changes."
  },
  {
    "objectID": "blog/2024/04/dinosaurs/index.html#measures-of-central-tendency",
    "href": "blog/2024/04/dinosaurs/index.html#measures-of-central-tendency",
    "title": "Animating the Datasaurus dataset as part of the 30 Day Chart Challenge",
    "section": "Measures of Central Tendency",
    "text": "Measures of Central Tendency\n\nCodelibrary(datasauRus) \nlibrary(knitr)\nlibrary(tidyverse)\n\ndatasaurus &lt;- datasaurus_dozen\ngroup_datasaurus &lt;- datasaurus %&gt;%\n  summarize(avg = mean(x), \n            stdev = sd(x), \n            avg_y = mean(y), \n            stdev_y = sd(y))\n\nknitr::kable(group_datasaurus,\n             col.names = c('Mean(x)','SD(x)','Mean(y)','SD(y)'))\n\n\n\n\nMean(x)\nSD(x)\nMean(y)\nSD(y)\n\n\n54.2657\n16.713\n47.8351\n26.84777\n\n\nMean & Standard Deviation of x and y remain equal for each dataset\n\n\nCode## -------------------------------------- ##\n## Day 19: Dinosaurs; 30DayChartChallenge ##\n## -------------------------------------- ##\n## Loading libs                           ##\nlibrary(datasauRus)                       ##\nlibrary(tidyverse)                        ##\nlibrary(gganimate)                        ##                                                    \nlibrary(showtext)                         ##\n## -------------------------------------- ##\n\n# Setting custom theme for ggplot2 graphics\n\nclrs &lt;- c( # Creating custom color palette\n  \"#e5b858\", #  yellow\n  \"#B72025\", #  red\n  \"#7C225C\", #  purple\n  \"#d3d6d9\", #  dark gray\n  \"#f9f9f9\", #  light gray\n  \"#394DAA\") #  blue\n\n# Import Fonts (google name, R name)\nfont_add_google(\"Source Code Pro\",\"source_code\")\nfont_add_google(\"Montserrat\",\"mont\")\nshowtext_auto() # enable showtext font rendering\n\ntheme_blue &lt;- function() {\n  theme_minimal(base_family = \"mont\") +\n  theme(\n    plot.title = element_text(family = \"mont\", face = \"bold\", size = rel(1.35)),\n    plot.subtitle = element_text(family = \"mont\", colour = \"royalblue\", face = \"plain\", size = rel(1)),\n    plot.background = element_rect(fill = clrs[5], colour = clrs[5]),\n    panel.border = element_blank(),\n    panel.background = element_rect(fill = clrs[5]),\n    panel.grid.major.x = element_line(colour = clrs[6], linetype = 3, linewidth = .35),\n    panel.grid.minor.x = element_blank(),\n    panel.grid.major.y =  element_line(colour = clrs[6], linetype = 3, linewidth = .35),\n    panel.grid.minor.y = element_blank(),\n    # modify text, axis and colour 4) and 5)\n    axis.text = element_text(colour = clrs[6], face = \"plain\", family = \"mont\"),\n    axis.title = element_text(colour = clrs[6], family = \"mont\"),\n    axis.ticks = element_line(colour = clrs[6]),\n    # legend at the bottom 6)\n    legend.position = \"none\"\n  )\n}\n\ntheme_set(theme_blue())\n\nggplot2::update_geom_defaults(\"label\", list(family = \"mont\", fontface = \"bold\"))\nggplot2::update_geom_defaults(\"text\", list(family = \"mont\", fontface = \"plain\"))\n\n\n# Checking min/max for axis transform\ndatasaurus &lt;- datasaurus_dozen\nsummary(datasaurus)\n\ndino &lt;- ggplot(datasaurus, aes(x = x, y = y))+\n  geom_point(size = 3, alpha = .65, \n             colour = clrs[3]) +\n  labs(x = NULL,y = NULL,\n       title = \"Day 19 of 30 Day Chart Challenge\",\n       subtitle = \"The T-rex\",\n       caption = \"Always check your data graphically\") +\n  theme_blue() +\n  transition_states(states = dataset,\n                    transition_length = 2,\n                    state_length = 1,\n                    wrap = TRUE) +\n  ease_aes(\"linear\")\n\nanimate(dino, duration = 15, fps = 24, height = 680, width = 720,\n        renderer = gifski_renderer())\n\nanim_save(filename = \"dino.gif\",\n          path = here::here(\"blog\",\"2024\",\"04\",\"dinosaurs\",\"img\"))"
  },
  {
    "objectID": "blog/2024/04/dinosaurs/index.html#the-animated-data",
    "href": "blog/2024/04/dinosaurs/index.html#the-animated-data",
    "title": "Animating the Datasaurus dataset as part of the 30 Day Chart Challenge",
    "section": "The Animated Data",
    "text": "The Animated Data"
  },
  {
    "objectID": "cv/index.html",
    "href": "cv/index.html",
    "title": "Résumé",
    "section": "",
    "text": "Download résumé"
  },
  {
    "objectID": "now/index.html",
    "href": "now/index.html",
    "title": "Nowadays",
    "section": "",
    "text": "This year will be a busy one for me:\n\nI’m doing my MPH in Epidemiology and figuring out what research opportunities are available at my university.\nAfter the COVID-19 pandemic, I’ve been working from home and spent a lot of time with my family.\nI’m working full-time as a Learning and Development Specialist, doing some freelancing, and working on personal projects on the side whenever I get a chance.\nI’m deepening my understanding of statistics and programming and that occupies a good chunk of my free time.\nI have been obsessed with kettlebells for the past two and a half years. I’ve mastered a few movements but there’s still a lot of ground to cover.\nEversince we moved to our new house, I’ve been working on some house repairs.\nI’ve been reading science and religion books for the past three years until recently, when I decided to reread the classics and tell them to my girls who aren’t old enough to read those yet."
  },
  {
    "objectID": "research/index.html",
    "href": "research/index.html",
    "title": "Research",
    "section": "",
    "text": "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."
  },
  {
    "objectID": "research/index.html#journal-articles",
    "href": "research/index.html#journal-articles",
    "title": "Research",
    "section": "Journal articles",
    "text": "Journal articles\n\n\n\n    \n        \n            \n                Julian Bashir and Elim Garak, “On the Surgical Removal of Cardassian Cranial Implants: A case study of a Cardassian patient” Starbase Deep Nine Archives 130, no. 9 (September 2178): 1425–1439\n            \n\n            \n\n            \n            \n            \n            \n                These brain distortions–\n            \n                 / horse loose in a hospital.\n            \n                 / Surgery?...Proceed.\n            \n            \n            \n            \n            \n                \n                    \n                        \n                             Full details »\n                        \n                    \n                    \n                        \n                    \n                        \n                        \n                        \n                             Preprint\n                        \n                    \n                        \n                    \n                        \n                        \n                        \n                             Final version\n                        \n                    \n                        \n                    \n                        \n                        \n                        \n                             Code\n                        \n                    \n                        \n                    \n                        \n                        \n                        \n                             Add to Mendeley\n                        \n                    \n                        \n                    \n                \n            \n        \n        \n\n\n\nNo matching items"
  },
  {
    "objectID": "blog/2024/05/index.html",
    "href": "blog/2024/05/index.html",
    "title": "Geographical Information Systems (GIS) and R. An Overview",
    "section": "",
    "text": "A Geographic Information System is a multi–component environment used to create, visualize, analyze, and manage data with a spatial component. GIS allows us to use coordinate planes to plot geographical data by assigning observation pairs– points, to lines, polygons, or rasters.\n      In theory, we can use a GIS environment to plot any dataset that’s mapped onto a coordinate system, but our research questions will decide whether it is appropriate to do so. If we would like to know how many dogs there are in New York City’s boroughs, we can use a table or a scatterplot to display this information. However, if we’re interested in learning whether boroughs with a greater number of dogs are geographically adjacent, we may choose to use a GIS as a simple scatterplot will not provide a clear answer.\n      What sort of information do we actually need to answer the previous question? Well, we would need the latitude and longitude of each borough to determine its boundaries and their placement on a coordinate system. These measurements are stored in a spatial database, not a .csv or .txt file."
  },
  {
    "objectID": "blog/2024/05/index.html#what-is-a-gis",
    "href": "blog/2024/05/index.html#what-is-a-gis",
    "title": "Geographical Information Systems (GIS) and R. An Overview",
    "section": "",
    "text": "A Geographic Information System is a multi–component environment used to create, visualize, analyze, and manage data with a spatial component. GIS allows us to use coordinate planes to plot geographical data by assigning observation pairs– points, to lines, polygons, or rasters.\n      In theory, we can use a GIS environment to plot any dataset that’s mapped onto a coordinate system, but our research questions will decide whether it is appropriate to do so. If we would like to know how many dogs there are in New York City’s boroughs, we can use a table or a scatterplot to display this information. However, if we’re interested in learning whether boroughs with a greater number of dogs are geographically adjacent, we may choose to use a GIS as a simple scatterplot will not provide a clear answer.\n      What sort of information do we actually need to answer the previous question? Well, we would need the latitude and longitude of each borough to determine its boundaries and their placement on a coordinate system. These measurements are stored in a spatial database, not a .csv or .txt file."
  },
  {
    "objectID": "blog/2024/05/index.html#spatial-analysis",
    "href": "blog/2024/05/index.html#spatial-analysis",
    "title": "Geographical Information Systems (GIS) and R. An Overview",
    "section": "Spatial Analysis",
    "text": "Spatial Analysis\nWe use GIS for spatial analysis, and this sort of analysis is usually associated with maps but more importantly with the statistical analysis of spatial patterns and underlying processes. By using GIS to perform spatial analysis, we aim to quantify1 the observed pattern and try to explore its origin or occurrence.\n1 The statistical analysis is performed in R not the GIS softwareVectors and Rasters\n      Spatial analysis requires our real–world observations to be reshaped as a vector or raster data model. Vectors can be points, lines, and polygons. Points are observation pairs representing a specific location in a coordinate system. Points have no area, but we conveniently represent them using symbols. Lines are a sequence of two or more points called vertices that are interconnected. Lines do not possess area and can’t be seen, but we symbolize them with shapes and colors. Polygons, on the other hand, are composed of at least three line segments with equivalent initial and final points. Polygons possess length, area, and separate their inside and outside features explicitly. Geometric figures are polygons, therefore, it seems intuitive that our polygon vectors also have this feature.\n      The raster data model uses an array of cells to represent real–world objects such as images, temperatures, and elevations. The structure of a raster is typically rectangular with regularly spaced cells having a value associated with it. These values have a magnitude that is measured at every cell within the grid and represented as a scalar field on a coordinate system2.\n2  Surface temperatures are an example of this field view of rasters. We can measure temperature and represent it based on its magnitude.The issue of Scaling\n      Our real–world observations have been reshaped as either a vector or raster, and now we must decide how to represent them on a grid. In GIS, the scale of our map is the ratio of distance on the map to that in the real world. If we want to represent the southern states, a large area, we will use a small scale map, but if we’re looking to represent the downtown area of a large city in the south, a relatively small area, we use a large scale.\nColors as symbols\n      Color should also inform our scaling choices. We should carefully pick colors to represent features in our dataset. Each color is a combination of three dimensions: hue, lightness, and saturation. We use hue, the dimension associated with color names, to represent different categories of data. Lightness describes how much light is reflected off of a surface. We represent ordinal, interval, and ratio using hue and lightness. Saturation is a color’s sharpness, and it’s commonly used to distinguish3 map symbols.\n3 Use qualitative color schemes for categorical, unordered data. Ordered, interval and continuous data should use sequential or divergent color themes.\nCode## ---------------------- ##\n## Creating color schemes ##\n## ---------------------- ##\n\n# Using the rgb() function and https://medialab.github.io/iwanthue\n\nrgb.frame &lt;- function(string){ # function to rmv ()and split string\n  rgb &lt;- data.frame(do.call(rbind, strsplit(gsub(\"rgb\\\\(|\\\\)\", \"\", string), \",\")))\ncolnames(rgb) &lt;- c(\"r\", \"g\", \"b\")\nrgb&lt;- sapply(rgb, as.numeric) # Convert columns to matrix\nrgb &lt;- as.data.frame(rgb/255) # Convert o values between [0,1]\nreturn(rgb)\n}\n# ------------------------------------------------------ #\n# Seven pirmary and secondary colors hues\nrgb_strings &lt;- c(\"rgb(205,78,51)\",\n                    \"rgb(190,125,67)\",\n                    \"rgb(190,171,46)\",\n                    \"rgb(93,157,81)\",\n                    \"rgb(113,137,195)\",\n                    \"rgb(172,91,196)\",\n                    \"rgb(208,95,133)\")\n\nrgb &lt;- rgb.frame(rgb_strings)\n\n# Same colors with higher lightness\nstrings &lt;- c(\"rgb(209,137,95)\",\n              \"rgb(189,150,109)\",\n              \"rgb(178,170,97)\",\n              \"rgb(134,170,129)\",\n              \"rgb(128,164,190)\",\n              \"rgb(144,145,212)\",\n              \"rgb(199,131,151)\")\nrgb2 &lt;- rgb.frame(strings)\n\n# Same color with Lower Saturation\nstrings3 &lt;- c(\"rgb(191,105,67)\",\n             \"rgb(168,126,81)\",\n             \"rgb(161,151,64)\",\n             \"rgb(106,153,108)\",\n             \"rgb(112,144,173)\",\n             \"rgb(138,120,195)\",\n             \"rgb(185,106,131)\")\n\nrgb3 &lt;- rgb.frame(strings3)\n# ------------------------------------------------------ #\n# Choose fonts, create plots objects and arrange in grid\n\n# Add fonts\nfont_add_google(\"Lora\",\"lora\")\nshowtext_auto()\nfont &lt;- \"lora\"\n\n# Plot objects\npal1 &lt;- data.frame(color =rgb(rgb$r, rgb$g, rgb$b))\npal2 &lt;- data.frame(color = rgb(rgb2$r, rgb2$g, rgb2$b))\npal3 &lt;- data.frame(color = rgb(rgb3$r, rgb3$g, rgb3$b))\n\n# Create plots for hue,lightness, and saturation\nplot1 &lt;- ggplot(pal1, aes(x = 1, y = seq_along(color), fill = color)) +\n  geom_tile() +\n  scale_fill_identity() +\n  labs(title = \"Hue\") +\n  theme_void() +\n  theme(\n    plot.title = element_text(family = font, size = 14, face = \"bold\",\n                              hjust = .5),\n    plot.background = element_rect(fill =\"gray98\", colour = NA),\n    panel.background = element_blank(),\n    legend.position = \"none\")\n\n\nplot2 &lt;- ggplot(pal3, aes(x = 1, y = seq_along(color), fill = color)) +\n  geom_tile() +\n  scale_fill_identity() +\n  labs(title = \"Lightness\") +\n  theme_void() +\n  theme(\n    plot.title = element_text(family = font, size = 14, face = \"bold\",\n                              hjust = .5),\n    plot.background = element_rect(fill =\"gray98\", colour = NA),\n    panel.background = element_blank(),\n    legend.position = \"none\")\n  \nplot3 &lt;- ggplot(pal2, aes(x = 1, y = seq_along(color), fill = color)) +\n  geom_tile() +\n  scale_fill_identity() +\n  labs(title = \"Saturation\") +\n  theme_void() +\n  theme(\n    plot.title = element_text(family = font, size = 14, face = \"bold\",\n                              hjust = .5),\n    plot.background = element_rect(fill =\"gray98\", colour = NA),\n    panel.background = element_blank(),\n    legend.position = \"none\")\n\ngrid.arrange(plot1, plot2, plot3, ncol =3, nrow = 1)\n\n\n\n\n\n\n\nHues, lightness and saturation of seven primary and secondary colors\n\n\n  Text goes here\n\n\n\n\n\n\nHelpful Tip\n\n\n\nUse the color brewer to pick a set of color swatches to match your data. You can also visit the iwanthue site to find refined palettes of optimally distinct colors.\n\n\nUse Kieran Healy’s example of the nycdogs package to visualize a table and map using GIS"
  },
  {
    "objectID": "blog/2024/05/prisoners/index.html",
    "href": "blog/2024/05/prisoners/index.html",
    "title": "The Iterated Prisoners’ Dilemma",
    "section": "",
    "text": "Ideally, all humans would cooperate and live in harmony in a world where evil is not partaken. Unfortunately, that world doesn’t exist yet so we’re stuck with the question of cooperation. Should we always cooperate? Yes…not so quickly!.\nAs R. Axelrod1 put it:\n1 The Evolution of Cooperation. Basic Books, Inc. New York, 1984\nThe Cooperation theory [here] is based upon an investigation of individuals who pursue their own self–interest wihtout the aid of central authority to force them to cooperate with each other. The reason for assuming self–interest is that it allows an examination of the difficult case when cooperation is not completely based upon a concern for others or upon the welfare of the groups as a whole.\n\n\nThis iterated version of the dilemma was presented as a hypothetical scenario by R. Axelrod:\nTwo bank robbers happen to meet. They decide to pull a job together. The cops nab them, but without enough evidence to convict. They need a confession. And they know both robbers are unlikely to talk, since if neither implicates the other, the cops can keep them in jail for only 30 days.\nSo they put the two in separate cells. They go to the first prisoner and say: “If you rat on your partner and he stays mum, we’ll let you go and he’ll do ten years.If you both rat on each other, you’ll both do eight years.” Then they go to the second prisoner and say the same thing.\nThe first prisoner thinks it over. “If he rats on me and I don’t rat on him, then I lose big-time. If I rat on him and he doesn’t rat on me, then I win big-time. Either way, the smart move is to rat on him. I’ll just hope he’s a sucker and doesn’t rat on me.” The second prisoner reasons the same way. So they rat on each other, and the cops get their two convictions. If the prisoners had cooperated, both would have gotten off easy. Instead, the rational pursuit of self-interest has put them both in a world of pain.\nTo win the game, at least one player must cooperate in the face of betrayal, otherwise both contestants would face unfavorable outcomes.\n\nThe rules of Axelrod’s iterated prisoner’s dilemma:\n\nTwo players play 200 matches against each other and against an algorithm that betrayed or cooperated at random.\nPlayers obtain three points for mutual cooperation, one for a mutual betrayal, and five for the player who betrays when the other cooperates.\n\n\nI’ll attempt to provide four solutions to this problem. The first one will never be the first to betray but will copy the opponent’s previous choice; the second solution will betray in response to a cooperation five percent of the time; the third solution will cooperate first and then imitate each of player 1’s choices, and the last one will never betray first, but will retaliate in turn on every remaining move until the end of the game The official winning strategy was the following:\n\nIn the first match-up, cooperate.\nIn every match-up after that, do what the opponent did in the preceding match-up.\n\nI’ll imitate this strategy in the first algorithm and decide on the choices for player 1.\nFirst, I’ll assign values to the three possible outcomes: Mutual cooperation is represented by the integer 3. Mutual betrayal is represented by 1, and Unmet cooperation is represented by 5. Player’s choices will be represented by betrayal equals 1 and cooperation equals 2.\n\noutcomes &lt;- factor(c(1,3,5), labels = c(\"Mutual Cooperation\", \"Mutual Betrayal\",\"Unmet Cooperation\"))\nchoices &lt;- factor(c(1,2), labels = c(\"Betray\", \"Cooperate\"))\n\n#&gt; Player 1 choices (46% prob of betrayal, 24% prob cooperation)\np1_choice &lt;- as.numeric(sample(choices,200,replace = T, prob = c(.459,.237)))\ntable(p1_choice)\n#&gt; p1_choice\n#&gt;   1   2 \n#&gt; 132  68\n\nNow I have to create a function for player 2 that chooses to cooperate on the first attempt, and copies player 1’s choice on subsequent ones. To do this, I have to iterate over each of player 1’s choice, and store player 2’s replies in a new vector.\nTo determine the choice order, I’ll create a vector of length 2 with player 1’s original choice and subtract 1 from that choice to obtain the alternative. To create the vector of choices of length n, I’ll append player 1’s original choice to a vector of length n-1 to make sure the first choice is always in position 1 p1_choice[1]. The resulting vector will be of length n.\nTo create the vector or player 2’s choices using the tit–for–tat algorithm, I’ll create a vector of length n equal to p1_choice. The first choice will always be cooperation, and all subsequent choices will be player 1’s previous response p1[ i -1].\n\n\n\n\n\n\nAlways remember to initialize vectors and perform operations outside the loop, if possible. Doing this will sometimes make your function much, much faster.\n\n\n\n\n#&gt; @rounds: number of rounds or matches in one game\n#&gt; @prob: probability of betrayal and cooperation\n#&gt; @choice: first choice to start the game. Choice inversion will be applied if staring choice = 1\n#&gt; @replace: sampling with replacement based on choice order. A vector of length 2\n\ntit.for.tat &lt;- function(rounds, \n                        prob, \n                        choice,\n                        replace = TRUE){\n  \n  #Check arguments\n  stopifnot({ \n  is.integer(rounds)\n  is.double(prob)\n  is.logical(choice)\n  is.logical(replace)})\n  \n  choice_order &lt;- c(choice,1 - choice)\n  n &lt;- rounds -1\n  # Choice inversion if choice  = 1\n  if(choice_order[1] == 1){\n    inv.prob &lt;- c(prob[2],prob[1])\n    p1 &lt;- c(choice,sample(choice_order,size = n,replace = replace,prob = inv.prob))\n  } else{\n    p1 &lt;- c(choice,sample(choice_order,size = n,replace = replace,prob = prob))\n  }\n  p2 &lt;- numeric(length(p1))\n  p2[1] &lt;- 1\n  \n  for(i in 2:length(p1)){\n    p2[i] &lt;- p1[i -1]\n  }\n  return(p2)\n}\n\ntable(tit.for.tat(200,prob = c(.459,.237), choice = 0, replace = T))\n#&gt; \n#&gt;   0   1 \n#&gt; 124  76\n\n\nThe only difference between Tit–for–Tat and the IBP2 is that we’re adding a random element that will cause player 2 to betray player 1 when faced with a cooperative response. Player 2 will always cooperate on the first round, but the algorithm will be less predictable than the previous one. Not to spoil it, but I think this one will not do as well as Tit–for–Tat.\n2 This strategy follows the Joss strategy featured in the 1984 book by R. Axelrod3 in theory, this should happen 5% of the time for the uniform distributionTo implement the random component needed to defect on 5% of cooperative responses, I will identify each time player 1 chooses to cooperate and then defect when randomly generated number from the uniform distribution is less than or equal to .053. If the randomly generated number is greater than my default, I’ll revert back to the tit–for–tat strategy.\n\n#&gt; @prob: probability of betrayal and cooperation\n#&gt; @default: percentage of cooperative responses on which player 2 betrays player 1\n\nprober &lt;- function(rounds, \n                   prob,\n                   choice,\n                   default,\n                   replace = TRUE){\n  \n    #Check arguments\n  stopifnot({ \n  is.integer(rounds)\n  is.double(prob)\n  is.logical(choice)\n  is.double(default)\n  is.logical(replace)})\n  \n  choice_order &lt;- c(choice, 1 - choice)\n  n &lt;- rounds - 1\n  if(choice_order[1] == 1){\n    inv.prob &lt;- c(prob[2],prob[1])\n    p1 &lt;- c(choice,sample(choice_order,size = n,replace = replace,prob = inv.prob))\n  } else{\n    p1 &lt;- c(choice,sample(choice_order,size = n,replace = replace,prob = prob))\n  }\n  p2 &lt;- numeric(length(p1))\n  p2[1] &lt;- 1\n  \nfor (i in 2:length(p1)) {\n  if (p1[i - 1] == 1) {\n    if (runif(1) &lt; default) { # % chance to switch from 1 to 0\n      p2[i] &lt;- 0\n    } else {\n      p2[i] &lt;- p1[i - 1]\n    }\n  } else {\n    \n    p2[i] &lt;- p1[i -1]\n  }\n}\n  return(p2)\n}\n\ntable(prober(200,prob = c(.459,.237), choice = 0, default = .05, replace = T))\n#&gt; \n#&gt;   0   1 \n#&gt; 133  67\n\n\nA less glorious but more common solution is to simply imitate each of player 1 moves to a T. Player 2 will never cooperate first unless player 1 chooses to cooperate. This copy cat algorithm is looking at the current round and copying the first player’s moves. It is not concerned with the previous moves.\n\n\ncopy.cat &lt;- function(rounds, \n                   prob,\n                   choice,\n                   replace = TRUE){\n  \n    #Check arguments\n  stopifnot({ \n  is.integer(rounds)\n  is.double(prob)\n  is.logical(choice)\n  is.logical(replace)})\n  \n  choice_order &lt;- c(choice, 1 - choice)\n  n &lt;- rounds - 1\n  if(choice_order[1] == 1){\n    inv.prob &lt;- c(prob[2],prob[1])\n    p1 &lt;- c(choice,sample(choice_order,size = n,replace = replace,prob = inv.prob))\n  } else{\n    p1 &lt;- c(choice,sample(choice_order,size = n,replace = replace,prob = prob))\n  }\n  p2 &lt;- numeric(length(p1))\n  p2[1] &lt;- 1\n  \n  for(i in 2:length(p1)){\n    if(p1[i] == 1){\n      p2[i] &lt;- 1\n    } else {\n      p2[i] &lt;- 0\n    }\n  }\n  return(p2)\n}\n\ntable(copy.cat(200,prob = c(.459,.237), choice = 0, replace = T))\n#&gt; \n#&gt;   0   1 \n#&gt; 124  76\n\n\nThe last algorithm will not play nice on the first round and will exact revenge on player 1 until the game is over4. This player is a more revengeful fellow. Let’s see how to implement it.\n4 A copy of the aggressive Friedman’s algorithmThe key to achieve such vengeful results is to track when player 1 switches from betrayals to cooperation. Once we identify a cooperation, player 2 will no longer cooperate. I’ll only add one argument zero_switch to identify when player 1 chooses to defect. This logical vector will automatically switch to true inside the for loop, and will cause player 2 to defect on every move for the remainder of the game.\nSomething worthy of attention here is that if the probability of betrayal is higher than cooperation, the revenge algorithm will most likely never cooperate after the first couple of rounds. I’ll make sure to set a higher probability of cooperation to see the algorithm in action.\n\n\nexact.revenge &lt;- function(rounds, \n                   prob,\n                   choice,\n                   replace = TRUE){\n  \n    #Check arguments\n  stopifnot({ \n  is.integer(rounds)\n  is.double(prob)\n  is.logical(choice)\n  is.logical(replace)})\n  \n  choice_order &lt;- c(choice, 1 - choice)\n  n &lt;- rounds - 1\n  if(choice_order[1] == 1){\n    inv.prob &lt;- c(prob[2],prob[1])\n    p1 &lt;- c(choice,sample(choice_order,size = n,replace = replace,prob = inv.prob))\n  } else{\n    p1 &lt;- c(choice,sample(choice_order,size = n,replace = replace,prob = prob))\n  }\n  p2 &lt;- numeric(length(p1))\n  p2[1] &lt;- 1\n  zero_switch &lt;- FALSE\n  \n  for(i in 2:length(p1)){\n    if(p1[i -1] == 0){\n      zero_switch &lt;- TRUE\n    } \n    p2[i]&lt;- ifelse(zero_switch,0,1)\n  }\n  return(p2)\n}\n\ntable(exact.revenge(200,prob = c(.159,.437), choice = 1, replace = T))\n#&gt; \n#&gt;   0   1 \n#&gt; 193   7"
  },
  {
    "objectID": "blog/2024/05/prisoners/index.html#not-so-quickly",
    "href": "blog/2024/05/prisoners/index.html#not-so-quickly",
    "title": "The Iterated Prisoners’ Dilemma",
    "section": "",
    "text": "Ideally, all humans would cooperate and live in harmony in a world where evil is not partaken. Unfortunately, that world doesn’t exist yet so we’re stuck with the question of cooperation. Should we always cooperate? Yes…not so quickly!.\nAs R. Axelrod1 put it:\n1 The Evolution of Cooperation. Basic Books, Inc. New York, 1984\nThe Cooperation theory [here] is based upon an investigation of individuals who pursue their own self–interest wihtout the aid of central authority to force them to cooperate with each other. The reason for assuming self–interest is that it allows an examination of the difficult case when cooperation is not completely based upon a concern for others or upon the welfare of the groups as a whole.\n\n\nThis iterated version of the dilemma was presented as a hypothetical scenario by R. Axelrod:\nTwo bank robbers happen to meet. They decide to pull a job together. The cops nab them, but without enough evidence to convict. They need a confession. And they know both robbers are unlikely to talk, since if neither implicates the other, the cops can keep them in jail for only 30 days.\nSo they put the two in separate cells. They go to the first prisoner and say: “If you rat on your partner and he stays mum, we’ll let you go and he’ll do ten years.If you both rat on each other, you’ll both do eight years.” Then they go to the second prisoner and say the same thing.\nThe first prisoner thinks it over. “If he rats on me and I don’t rat on him, then I lose big-time. If I rat on him and he doesn’t rat on me, then I win big-time. Either way, the smart move is to rat on him. I’ll just hope he’s a sucker and doesn’t rat on me.” The second prisoner reasons the same way. So they rat on each other, and the cops get their two convictions. If the prisoners had cooperated, both would have gotten off easy. Instead, the rational pursuit of self-interest has put them both in a world of pain.\nTo win the game, at least one player must cooperate in the face of betrayal, otherwise both contestants would face unfavorable outcomes.\n\nThe rules of Axelrod’s iterated prisoner’s dilemma:\n\nTwo players play 200 matches against each other and against an algorithm that betrayed or cooperated at random.\nPlayers obtain three points for mutual cooperation, one for a mutual betrayal, and five for the player who betrays when the other cooperates.\n\n\nI’ll attempt to provide four solutions to this problem. The first one will never be the first to betray but will copy the opponent’s previous choice; the second solution will betray in response to a cooperation five percent of the time; the third solution will cooperate first and then imitate each of player 1’s choices, and the last one will never betray first, but will retaliate in turn on every remaining move until the end of the game The official winning strategy was the following:\n\nIn the first match-up, cooperate.\nIn every match-up after that, do what the opponent did in the preceding match-up.\n\nI’ll imitate this strategy in the first algorithm and decide on the choices for player 1.\nFirst, I’ll assign values to the three possible outcomes: Mutual cooperation is represented by the integer 3. Mutual betrayal is represented by 1, and Unmet cooperation is represented by 5. Player’s choices will be represented by betrayal equals 1 and cooperation equals 2.\n\noutcomes &lt;- factor(c(1,3,5), labels = c(\"Mutual Cooperation\", \"Mutual Betrayal\",\"Unmet Cooperation\"))\nchoices &lt;- factor(c(1,2), labels = c(\"Betray\", \"Cooperate\"))\n\n#&gt; Player 1 choices (46% prob of betrayal, 24% prob cooperation)\np1_choice &lt;- as.numeric(sample(choices,200,replace = T, prob = c(.459,.237)))\ntable(p1_choice)\n#&gt; p1_choice\n#&gt;   1   2 \n#&gt; 132  68\n\nNow I have to create a function for player 2 that chooses to cooperate on the first attempt, and copies player 1’s choice on subsequent ones. To do this, I have to iterate over each of player 1’s choice, and store player 2’s replies in a new vector.\nTo determine the choice order, I’ll create a vector of length 2 with player 1’s original choice and subtract 1 from that choice to obtain the alternative. To create the vector of choices of length n, I’ll append player 1’s original choice to a vector of length n-1 to make sure the first choice is always in position 1 p1_choice[1]. The resulting vector will be of length n.\nTo create the vector or player 2’s choices using the tit–for–tat algorithm, I’ll create a vector of length n equal to p1_choice. The first choice will always be cooperation, and all subsequent choices will be player 1’s previous response p1[ i -1].\n\n\n\n\n\n\nAlways remember to initialize vectors and perform operations outside the loop, if possible. Doing this will sometimes make your function much, much faster.\n\n\n\n\n#&gt; @rounds: number of rounds or matches in one game\n#&gt; @prob: probability of betrayal and cooperation\n#&gt; @choice: first choice to start the game. Choice inversion will be applied if staring choice = 1\n#&gt; @replace: sampling with replacement based on choice order. A vector of length 2\n\ntit.for.tat &lt;- function(rounds, \n                        prob, \n                        choice,\n                        replace = TRUE){\n  \n  #Check arguments\n  stopifnot({ \n  is.integer(rounds)\n  is.double(prob)\n  is.logical(choice)\n  is.logical(replace)})\n  \n  choice_order &lt;- c(choice,1 - choice)\n  n &lt;- rounds -1\n  # Choice inversion if choice  = 1\n  if(choice_order[1] == 1){\n    inv.prob &lt;- c(prob[2],prob[1])\n    p1 &lt;- c(choice,sample(choice_order,size = n,replace = replace,prob = inv.prob))\n  } else{\n    p1 &lt;- c(choice,sample(choice_order,size = n,replace = replace,prob = prob))\n  }\n  p2 &lt;- numeric(length(p1))\n  p2[1] &lt;- 1\n  \n  for(i in 2:length(p1)){\n    p2[i] &lt;- p1[i -1]\n  }\n  return(p2)\n}\n\ntable(tit.for.tat(200,prob = c(.459,.237), choice = 0, replace = T))\n#&gt; \n#&gt;   0   1 \n#&gt; 124  76\n\n\nThe only difference between Tit–for–Tat and the IBP2 is that we’re adding a random element that will cause player 2 to betray player 1 when faced with a cooperative response. Player 2 will always cooperate on the first round, but the algorithm will be less predictable than the previous one. Not to spoil it, but I think this one will not do as well as Tit–for–Tat.\n2 This strategy follows the Joss strategy featured in the 1984 book by R. Axelrod3 in theory, this should happen 5% of the time for the uniform distributionTo implement the random component needed to defect on 5% of cooperative responses, I will identify each time player 1 chooses to cooperate and then defect when randomly generated number from the uniform distribution is less than or equal to .053. If the randomly generated number is greater than my default, I’ll revert back to the tit–for–tat strategy.\n\n#&gt; @prob: probability of betrayal and cooperation\n#&gt; @default: percentage of cooperative responses on which player 2 betrays player 1\n\nprober &lt;- function(rounds, \n                   prob,\n                   choice,\n                   default,\n                   replace = TRUE){\n  \n    #Check arguments\n  stopifnot({ \n  is.integer(rounds)\n  is.double(prob)\n  is.logical(choice)\n  is.double(default)\n  is.logical(replace)})\n  \n  choice_order &lt;- c(choice, 1 - choice)\n  n &lt;- rounds - 1\n  if(choice_order[1] == 1){\n    inv.prob &lt;- c(prob[2],prob[1])\n    p1 &lt;- c(choice,sample(choice_order,size = n,replace = replace,prob = inv.prob))\n  } else{\n    p1 &lt;- c(choice,sample(choice_order,size = n,replace = replace,prob = prob))\n  }\n  p2 &lt;- numeric(length(p1))\n  p2[1] &lt;- 1\n  \nfor (i in 2:length(p1)) {\n  if (p1[i - 1] == 1) {\n    if (runif(1) &lt; default) { # % chance to switch from 1 to 0\n      p2[i] &lt;- 0\n    } else {\n      p2[i] &lt;- p1[i - 1]\n    }\n  } else {\n    \n    p2[i] &lt;- p1[i -1]\n  }\n}\n  return(p2)\n}\n\ntable(prober(200,prob = c(.459,.237), choice = 0, default = .05, replace = T))\n#&gt; \n#&gt;   0   1 \n#&gt; 133  67\n\n\nA less glorious but more common solution is to simply imitate each of player 1 moves to a T. Player 2 will never cooperate first unless player 1 chooses to cooperate. This copy cat algorithm is looking at the current round and copying the first player’s moves. It is not concerned with the previous moves.\n\n\ncopy.cat &lt;- function(rounds, \n                   prob,\n                   choice,\n                   replace = TRUE){\n  \n    #Check arguments\n  stopifnot({ \n  is.integer(rounds)\n  is.double(prob)\n  is.logical(choice)\n  is.logical(replace)})\n  \n  choice_order &lt;- c(choice, 1 - choice)\n  n &lt;- rounds - 1\n  if(choice_order[1] == 1){\n    inv.prob &lt;- c(prob[2],prob[1])\n    p1 &lt;- c(choice,sample(choice_order,size = n,replace = replace,prob = inv.prob))\n  } else{\n    p1 &lt;- c(choice,sample(choice_order,size = n,replace = replace,prob = prob))\n  }\n  p2 &lt;- numeric(length(p1))\n  p2[1] &lt;- 1\n  \n  for(i in 2:length(p1)){\n    if(p1[i] == 1){\n      p2[i] &lt;- 1\n    } else {\n      p2[i] &lt;- 0\n    }\n  }\n  return(p2)\n}\n\ntable(copy.cat(200,prob = c(.459,.237), choice = 0, replace = T))\n#&gt; \n#&gt;   0   1 \n#&gt; 124  76\n\n\nThe last algorithm will not play nice on the first round and will exact revenge on player 1 until the game is over4. This player is a more revengeful fellow. Let’s see how to implement it.\n4 A copy of the aggressive Friedman’s algorithmThe key to achieve such vengeful results is to track when player 1 switches from betrayals to cooperation. Once we identify a cooperation, player 2 will no longer cooperate. I’ll only add one argument zero_switch to identify when player 1 chooses to defect. This logical vector will automatically switch to true inside the for loop, and will cause player 2 to defect on every move for the remainder of the game.\nSomething worthy of attention here is that if the probability of betrayal is higher than cooperation, the revenge algorithm will most likely never cooperate after the first couple of rounds. I’ll make sure to set a higher probability of cooperation to see the algorithm in action.\n\n\nexact.revenge &lt;- function(rounds, \n                   prob,\n                   choice,\n                   replace = TRUE){\n  \n    #Check arguments\n  stopifnot({ \n  is.integer(rounds)\n  is.double(prob)\n  is.logical(choice)\n  is.logical(replace)})\n  \n  choice_order &lt;- c(choice, 1 - choice)\n  n &lt;- rounds - 1\n  if(choice_order[1] == 1){\n    inv.prob &lt;- c(prob[2],prob[1])\n    p1 &lt;- c(choice,sample(choice_order,size = n,replace = replace,prob = inv.prob))\n  } else{\n    p1 &lt;- c(choice,sample(choice_order,size = n,replace = replace,prob = prob))\n  }\n  p2 &lt;- numeric(length(p1))\n  p2[1] &lt;- 1\n  zero_switch &lt;- FALSE\n  \n  for(i in 2:length(p1)){\n    if(p1[i -1] == 0){\n      zero_switch &lt;- TRUE\n    } \n    p2[i]&lt;- ifelse(zero_switch,0,1)\n  }\n  return(p2)\n}\n\ntable(exact.revenge(200,prob = c(.159,.437), choice = 1, replace = T))\n#&gt; \n#&gt;   0   1 \n#&gt; 193   7"
  },
  {
    "objectID": "blog/2024/05/prisoners/index.html#algorithm-perfomance",
    "href": "blog/2024/05/prisoners/index.html#algorithm-perfomance",
    "title": "The Iterated Prisoners’ Dilemma",
    "section": "Algorithm Perfomance",
    "text": "Algorithm Perfomance\nNow that all four algorithms are created, I’ll implement a function to evaluate the overall performance in total points after 200 rounds.\nFirst, I have to create an outcome matrix to store the outcome of each choice combination. Then, I have to create a function that repeatedly compares algorithms over n number of games. To do this, I would have to update choice order for each game, if necessary; store total number of choices per game in two vectors, one for each player, create a list and evaluate choice outcome against the outcome matrix, and then sum each player’s score in the new list to find the total number of points per game. Lastly, I would have to calculate the average number of total points per game and compare algorithms this way.\n\n#&gt; @(...) arguments include:\n#&gt;              @alg: algorithms to compare\n#&gt;              @rounds: number of rounds in a game\n#&gt;              @prob:   probability of betrayal and cooperation.\n#&gt;              @choice: starting choice.\n#&gt;              @default: percentage of cooperative responses on which player 2 betrays player 1\n#&gt; @iter: how many games of `n` rounds should be played.\n\ncomp.alg &lt;- function(alg,\n                     iter = NULL,\n                     rounds,\n                     prob,\n                     choice,\n                     replace = TRUE,\n                     ...){\n  #Check arguments\n  stopifnot({\n    is.list(alg)\n    is.numeric(iter) && iter &gt; 0})  \n  \n  out &lt;- matrix(c(3,5,0,1), nrow = 2, byrow = TRUE)\n        rownames(out) &lt;- c(\"P1.C\",\"P1.B\")\n        colnames(out) &lt;- c(\"P2.C\",\"P2.B\")\n  \n  play.game &lt;- function(rounds, \n                        prob,\n                        choice, \n                        default = NULL,\n                        replace = TRUE) {\n    p1 &lt;- do.call(alg[[1]],list(rounds = rounds,\n                                prob = prob,\n                                choice = choice,\n                                replace = replace))\n    p2 &lt;- do.call(alg[[2]],list(rounds = rounds,\n                                prob = prob,\n                                choice = choice,\n                                replace = replace))\n   \n  do.score &lt;- function(P1,P2){\n    l1 &lt;- list(P1,P2)\n    game_res &lt;- data.frame(P1 = numeric(length(P1)), \n                           P2 = numeric(length(P2)))\n    \n    for(i in seq_along(l1[[1]])){\n      c1 &lt;- l1[[1]][i]\n      c2 &lt;- l1[[2]][i]\n      \n      p1_score &lt;- out[c1 + 1, c2 + 1]\n      p2_score &lt;- t(out)[c1 + 1, c2 + 1]\n      \n      game_res$P1[i] &lt;- p1_score\n      game_res$P2[i] &lt;- p2_score\n    }\n     return(game_res)\n  }\n  out_game &lt;- do.score(p1,p2)\n  colSums(out_game)\n  }\n  \n  boot.results &lt;- list2DF(replicate(iter, play.game(rounds = rounds,\n                                prob = prob,\n                                choice = choice,\n                                replace = replace), simplify = FALSE))\n  \n  results &lt;- as.matrix(do.call(rbind,boot.results))\n  \n  \n  return(as.data.frame(results))\n}\n\n#Let's test it\ntest &lt;- comp.alg(c(copy.cat, tit.for.tat), \n                 iter = 500, \n                 rounds = 200, \n                 prob = c(.345, .231), \n                 choice = 0)\n\nhead(test)\n#&gt;    P1  P2\n#&gt; 1 516 491\n#&gt; 2 510 465\n#&gt; 3 460 490\n#&gt; 4 506 461\n#&gt; 5 469 479\n#&gt; 6 482 477\n\nCode Benchmarking\nFirst, I’ll look at the execution time and memory usage of my comp.alg function for several algorithms5. I’ll use the bench package to look at these two performance metrics. I’ll wrap my code in a function and measure its performance6\n5 The comp.alg function is not currently dealing with the default argument of the prober algorithm.I’m thinking of a way to implement it in a naturally efficient way.6 look up the bench::mark() function to see which metrics are calculated.The second step is to use bench::pres() to supply my wrapper function with a grid of values to use as iterations. Laslty, I’ll visualize the the number of iterations vs. execution time across algorithms.\n\n\n bench.comp.alg &lt;- function(iter){\n     bench::mark(\n         \"Copy\" = comp.alg(c(copy.cat,exact.revenge),iter = iter, rounds = 200, c(.25,.32),choice = 0)$P1,\n         \"Exact\" = comp.alg(c(copy.cat,exact.revenge),iter = iter, rounds = 200, c(.25,.32),choice = 0)$P2,\n         \"tft\" = comp.alg(c(tit.for.tat,exact.revenge),iter = iter, rounds = 200, c(.25,.32),choice = 0)$P1,\n         time_unit = \"ms\", \n         check = FALSE\n     )\n }\n\nresults &lt;- bench::press(\n     iter = c(10,50,100,300,500,700,900,1000),\n     bench.comp.alg(iter)\n )\n\n#&gt; A tibble: 24 × 14\n#&gt;   expression  iter    min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time result memory                   time            gc      \n#&gt;   &lt;bch:expr&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt;      &lt;dbl&gt; &lt;list&gt; &lt;list&gt;                   &lt;list&gt;          &lt;list&gt;  \n#&gt;  1 Copy          10   31.3   32.6    30.6      6.51MB     40.8     6     8       196. &lt;NULL&gt; &lt;Rprofmem [4,132 × 3]&gt;   &lt;bench_tm [14]&gt; &lt;tibble&gt;\n#&gt;  2 Exact         10   29.7   30.8    32.2      6.51MB     32.2     8     8       248. &lt;NULL&gt; &lt;Rprofmem [4,131 × 3]&gt;   &lt;bench_tm [16]&gt; &lt;tibble&gt;\n#&gt;  3 tft           10   30.8   32.4    30.8      6.51MB     30.8     7     7       227. &lt;NULL&gt; &lt;Rprofmem [4,131 × 3]&gt;   &lt;bench_tm [14]&gt; &lt;tibble&gt;\n#&gt;  4 Copy          50  207.   222.      4.40    32.55MB     14.7     3    10       681. &lt;NULL&gt; &lt;Rprofmem [20,668 × 3]&gt;  &lt;bench_tm [3]&gt;  &lt;tibble&gt;\n#&gt;  5 Exact         50  258.   262.      3.82    32.55MB     11.5     2     6       524. &lt;NULL&gt; &lt;Rprofmem [20,806 × 3]&gt;  &lt;bench_tm [2]&gt;  &lt;tibble&gt;\n #&gt; 6 tft           50  205.   266.      4.03    32.55MB     10.8     3     8       744. &lt;NULL&gt; &lt;Rprofmem [20,808 × 3]&gt;  &lt;bench_tm [3]&gt;  &lt;tibble&gt;\n#&gt;  7 Copy         100  576.   576.      1.74    65.09MB     12.2     1     7       576. &lt;NULL&gt; &lt;Rprofmem [41,418 × 3]&gt;  &lt;bench_tm [1]&gt;  &lt;tibble&gt;\n#&gt;  8 Exact        100  400.   411.      2.43    65.09MB     14.6     2    12       821. &lt;NULL&gt; &lt;Rprofmem [41,400 × 3]&gt;  &lt;bench_tm [2]&gt;  &lt;tibble&gt;\n#&gt;  9 tft          100  372.   390.      2.57    65.09MB     15.4     2    12       780. &lt;NULL&gt; &lt;Rprofmem [41,461 × 3]&gt;  &lt;bench_tm [2]&gt;  &lt;tibble&gt;\n#&gt; 10 Copy         300 1254.  1254.      0.798  195.27MB     10.4     1    13      1254. &lt;NULL&gt; &lt;Rprofmem [123,916 × 3]&gt; &lt;bench_tm [1]&gt;  &lt;tibble&gt;\n# ℹ 14 more rows\n# ℹ Use `print(n = ...)` to see more rows\n\nLet’s now visualize the performance of each algorithm using ggplot2.\n\n\nlibrary(ggplot2)\nlibrary(showtext)\n\n# Customize fonts\nfont_add_google(\"Ubuntu\",\"ubu\")\nshowtext_auto()\ntext &lt;- \"ubu\"\n\n\n\nggplot(results,\n       aes(iter,median, col = attr(expression,\"description\"))) +\n  geom_point(size = 4) +\n  geom_smooth(se = FALSE) +\n  labs(x = \"No. of iterations\",\n       y = \"Execution Time (ms)\",\n       colour = \"Algorithm\") +\n  #scale_color_manual(values = iter) +\n  theme_minimal() +\n  theme(legend.position = \"top\",\n        legend.title = element_text(family = text, size = 23),\n        legend.text = element_text(family = text, size = 18),\n        plot.background = element_rect(fill = \"#f8f9f9\",\n                                       color = \"NA\"),\n        axis.title = element_text(family = text, size = 18,\n                                  hjust = .5),\n        axis.text = element_text(family = text,size = 16),\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank()\n        )\n\n\n\n\n\n\n\n\n\nPractical Implications\nAmong all the algorithms submitted to Axelrod, the top performer was Tit–for–tat because it was “nice”. Algorithms that always betrayed or were “sneaky” were more likely to end up in a state of conflict.\nHere are the rules for strategic cooperation:\n\nAvoid unnecessary conflict by cooperating as long as your opponent does.\nIf your opponent betrays you without provocation— respond in kind…once.\nThen forgive the betrayal, and cooperate again.\nBe clear and predictable so your opponent knows how you act and can plan accordingly."
  }
]