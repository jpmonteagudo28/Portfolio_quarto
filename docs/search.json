[
  {
    "objectID": "blog/2024/06/moon/index.html",
    "href": "blog/2024/06/moon/index.html",
    "title": "swear not by the moon, the fickle moon",
    "section": "",
    "text": "Tip\n\n\n\nIf you‚Äôre wondering where I‚Äôm getting my titles and headings, they come from Shakespeare‚Äôs sonnets.\n\n\nThe moon has always fascinated me. Eversince I was a child, I was entranced by it; her constant pursuit everywhere I went and her sneaky tactics during the day. This year, before the solar eclipse, I decided to do a little digging and replicate one algorithm used to determine the phases of the moon. If you‚Äôre interested, you can find it here in this very dense book by Jean Meeus.\nIn case you didn‚Äôt know, the times of the new moon, first quarter, full moon, and last quarter are the times at which the moon‚Äôs longitude, as viewed from our planet, aligns with the sun to form 0\\(^\\circ\\), 90\\(^\\circ\\), 180\\(^\\circ\\), and 270\\(^\\circ\\), respectively. As the moon orbits the earth and rotates on its axis, it overlaps with the Sun in varying degrees, and thus light is reflected off of it. This means that to calculate the phases of the moon, we would technically need to know the geocentric1 longitude of the Moon and the Sun‚Ä¶and I‚Äôm not doing thatüôÉ so giving up a sliver of accuracy seems the right solution if we want to avoid an unorthodox amount of math.\n1¬†as viewed from the Earth\nAstronomers use Julian Ephemeris Days (JDE), or Dynamical Time (DT), as a measure of time to keep track of celestial bodies, and you probably guessed that its name may be derived from emperor Julius Caesar‚Äôs reform to create a calendar that always remained aligned to the sun, but that would be incorrect. It has nothing to do with Brutus‚Äôs uncle.\nThe first year under this calendar is Jan 1, 4,713 BC, which means that 2024 would represent the year 6737 of the Julian era‚Äîa pretty nerdy thing to point out, but nobody is complaininng, probably.\nTo find the JDE for any celestial event, we simply subtract 2,451,550 days from Ephemeris Time2, which is the number of days from 4713 BC to 1952‚Ä¶don‚Äôt quote me on thatüòÖ\n2¬†adopted in 1952The times of the mean phases of the moon are then given by:\n\\[\nJDE = 2,451,550.09766 + 29.530588861 k \\\\\n+ 0.00015437 T^{2} \\\\\n- 0.000000150 T^{3} \\\\\n+ 0.00000000073 T^{4}\n\\]\nwhere an integer value of \\(k = 0\\) gives a new moon3, and an increase by .25 gives the next phase, 1st quarter, full moon, and the third or last quarter. Any other value of \\(k\\) is meaningless.\n3¬†\\(k = 0\\) corresponds to the new moon of Jan 6, 2000, and negative values of \\(k\\) are lunar phases before the year 2000.\nThe approximate value of \\(k \\approx (year - 2000) √ó 12.3685\\) and the \\(year\\) variable should be expressed in decimals to include the month and day of the year. \\(T\\) is the time in Julian centuries since 2000, and we can accurately calculate it using this formula \\((\\frac{k}{1236.85})\\), and a term we haven‚Äôt seen yet, \\(E = 1 - 0.002516T - 0.0000074T^{2}\\) that describes the eccentricity of Earth‚Äôs orbit around the sun.\nThe angles for the sun‚Äôs and the moon‚Äôs mean anomaly4, the moon‚Äôs latitude and the longitude of the ascending node5 of the lunar orbit will also be calculated.\n4¬†distance from the center of the moon/sun measured from the side that is closest to earth assuming movement at a uniform speed in a circular orbit.5¬†the moon has an ascending and descending node where it crosses the ecliptic hemisphere from the south or the north, respectively.We need to take into account 14 planetary arguments and specific angles and time corrections for each phase of the moon to obtain any past, future and current Julian epochs. First, I‚Äôll create a simple function modf that will split an object of type double into its integer and decimal parts. I‚Äôll use this function to figure out the moon phase later down the road. A second function modr will reduce any angle to the range between 0‚Äì360, and a third function deg2rad will convert the degrees to radians, if necessary.\n\nCode for helper functions#&gt; Modulus fraction function\nmodf &lt;- function(k){\n     stopifnot(is.numeric(k))\n     kint &lt;- trunc(k)\n     kfrac &lt;- abs(k - kint)\n     kround &lt;- c(kint,kfrac)\n     return(kround)\n}\n\n#&gt; Modulus reduce angle function\nmodr &lt;- function(angle){\n  stopifnot(is.numeric(angle))\n  reduced &lt;- angle%%360\n  return(reduced)\n}\n\nrad2deg &lt;- function(rad){\n  stopifnot(is.numeric(rad))\n  degrees &lt;- (rad*180)/(pi)\n  return(degrees)\n}\n\ndeg2rad &lt;- function(deg){\n  stopifnot(is.numeric(deg))\n  radians &lt;- (deg*pi)/180\n  return(radians)\n}\n\ntest_it &lt;- modf(-3.35)\ntest &lt;- modr(400)\nprint(c(test_it,test))\n#&gt; [1] -3.00  0.35 40.00\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAlmost every function used here except the main function, modf,modr,deg2rad, rad2deg, and the dex.date functions are taken from Jean Meeus‚Äô ‚ÄúAstronomical Algorithms‚Äù.\n\n\nThe goal is to calculate the date of any lunar phase any number of years into the future. To do this, we‚Äôll first create functions for the mean anomaly, latitude, and longitude of the moon.\n\n#&gt; Times of lunar phases in JDE\nJDE &lt;- function(k,t){\n jde &lt;- 2451550.09766 + (29.530588861*k) + \n   0.00015437*(t^2) - 0.000000150*(t^3) + \n   0.00000000073*(t^4)\n jde &lt;- round(jde,digits = 6)\n return(jde)\n}\n#&gt; Calculate E\nE &lt;- function(k,t){\n  e &lt;- 1 - (0.002516*t) - 0.0000074*(t^2)\n  e &lt;- round(e,digits = 6)\n  return(e)\n}\n\n#&gt; Sun's mean anomaly at time JDE\nM &lt;- function(k,t){\n  m &lt;- 2.5534 + (29.10535670*k) - 0.0000014*(t^2) - 0.00000011*(t^3)\n  m &lt;- modr(round(m, digits = 6))\n  m &lt;- deg2rad(m)\n  return(m)\n}\n#&gt; Moon‚Äôs mean anomaly at time JDE\nM.prime &lt;- function(k,t){\n  m_prime &lt;- 201.5643 + (385.81693528*k) + 0.0107582*(t^2) + \n    0.00001238*(t^3) - 0.000000058*(t^4)\n  m_prime &lt;- modr(round(m_prime,digits = 6))\n  m_prime &lt;- deg2rad(m_prime)\n  return(m_prime)\n}\n#&gt; Moon's argument of latitude\nF &lt;- function(k,t){\n  f &lt;- 160.7108 + (390.67050284*k) - 0.0016118*(t^2) - \n    0.00000227*(t^3) + 0.000000011*(t^4)\n  f &lt;- modr(round(f, digits = 6))\n  f &lt;- deg2rad(f)\n  return(f)\n}\n\nomega &lt;- function(k,t){\n  o &lt;- 124.7746 - (1.56375588*k) + 0.0020672*(t^2) + 0.00000215*(t^3)\n  o &lt;- modr(round(0, digits = 6))\n  o &lt;- deg2rad(o)\n  return(o)\n}\n\nNow it‚Äôs time to come up with a function fo each planetary argument (14 total). Most of these argument take \\(k\\) with one exception \\(A_{1}\\), which also requires \\(T\\). The output of the planetary arguments are expressed in degrees and may have to be reduced to 0‚Äì360 and converted to radians. Since our main function does use every planetary argument to predict the lunar phases it may be better to provide the arguments as functions instead of vectors. if doing this is too torublesome, we‚Äôll try something different inside the main function.\n\nPlanetary Arguments functionsA1 &lt;- function(k,t){\n  a1 &lt;- 299.77 + 0.107408*k - 0.009173*(t^2)\n  a1 &lt;- modr(round(a1, digits = 6))\n  a1 &lt;- deg2rad(a1)\n  return(a1)\n}\nA2 &lt;- function(k){\n  a2 &lt;- 251.88 + 0.016321*k\n  a2 &lt;- modr(round(a2,digits = 6))\n  a2 &lt;- deg2rad(a2)\n  return(a2)\n}\nA3 &lt;- function(k){\n  a3 &lt;- 251.83 + 26.651886*k\n  a3 &lt;- modr(round(a3,digits = 6))\n  a3 &lt;- deg2rad(a3)\n  return(a3)\n}\n\nA4 &lt;- function(k){\n  a4 &lt;- 349.42 + 36.412478*k\n  a4 &lt;- modr(round(a4,digits = 6))\n  a4 &lt;- deg2rad(a4)\n  return(a4)\n}\nA5 &lt;- function(k){\n  a5 &lt;- 84.66 + 18.206239*k\n  a5 &lt;- modr(round(a5, digits = 6))\n  a5 &lt;- deg2rad(a5)\n  return(a5)\n}\nA6 &lt;- function(k){\n  a6 &lt;- 141.74 + 53.303771*k\n  a6 &lt;- modr(round(a6,digits = 6))\n  a6 &lt;- deg2rad(a6)\n  return(a6)\n}\nA7 &lt;- function(k){\n  a7 &lt;- 207.14 + 2.453732*k\n  a7 &lt;- modr(round(a7, digits = 6))\n  a7 &lt;- deg2rad(a7)\n  return(a7)\n}\nA8 &lt;- function(k){\n  a8 &lt;- 154.84 + 7.306860*k\n  a8 &lt;- modr(round(a8,digits = 6))\n  a8 &lt;- deg2rad(a8)\n  return(a8)\n}\nA9 &lt;- function(k){\n  a9 &lt;- 34.52 + 27.261239*k\n  a9 &lt;- modr(round(a9,digits = 6))\n  a9 &lt;- deg2rad(a9)\n  return(a9)\n}\nA10 &lt;- function(k){\n  a10 &lt;- 207.19 + 0.121824*k\n  a10 &lt;- modr(round(a10, digits = 6))\n  a10 &lt;- deg2rad(a10)\n  return(a10)\n}\nA11 &lt;- function(k){\n  a11 &lt;- 291.34 + 1.844379*k\n  a11 &lt;- modr(round(a11,digits = 6))\n  a11 &lt;- deg2rad(a11)\n  return(a11)\n}\nA12 &lt;- function(k){\n  a12 &lt;- 161.72 + 24.198154*k\n  a12 &lt;- modr(round(a12,digits = 6))\n  a12 &lt;- deg2rad(a12)\n  return(a12)\n}\nA13 &lt;- function(k){\n  a13 &lt;- 239.56 + 25.513099*k\n  a13 &lt;- modr(round(a13,digits = 6))\n  a13 &lt;- deg2rad(a13)\n  return(a13)\n}\nA14 &lt;- function(k){\n  a14 &lt;- 331.55 + 3.592518*k\n  a14 &lt;- modr(round(a14, digits = 6))\n  a14 &lt;- deg2rad(a14)\n  return(a14)\n}\n\n\n\nUsing the preciously coded functions, we‚Äôll create the main function with and add conditions for each moon phase to accurately implement the time corrections.\nSomething to keep in mind is that the date variable will have to be expressed as a decimal for the algorithm to work. This means that I‚Äôll have to transform the date outside the main function before doing any computations.\nThe output will be in date format so we‚Äôll need to look at R‚Äôs date manipulation capabilities. The built.in as.Date function won‚Äôt work for us because it doesn‚Äôt handle time (HH:MM:SS), so we‚Äôre left with two choices, the chron package which handles time but doesn‚Äôt account for timezones or the built.in POSIX classes that do manipulate timezones. I‚Äôm going with POSIXlt so that I can extract time information without pulling from external libraries.\n\nI‚Äôll test a simple function to transform a character string in the format \"YYYY/MM/DD\" to a POSIXlt date and then return a decimal to represent the number of days completed in any given year.\nSomething to note: Some years will be leap or century years, and this will also have to be dealt with. Additionally, we‚Äôre calculating the number of days completed up to the current date, which means we‚Äôll update our function to use day - 1 to find the decimal expression for the specified date.\n\ndex.date &lt;- function(date){\n  if (!inherits(date, c(\"POSIXt\", \"POSIXct\", \"POSIXlt\", \"Date\"))) {\n    #&gt; Transform to POSIXlt\n  POSIX_date &lt;- as.POSIXlt(date)\n#&gt; if the format is not found by the function, you can provide                                    \n#&gt; your format explicitly.\n  }\n  year &lt;- POSIX_date$year + 1900 \n#&gt; Pull the year attribute and add 1900, default is to subtract                                   \n#&gt; 1900 to provided year\n  day &lt;- as.numeric(format(POSIX_date,\"%j\")) # day of the year 0 - 365\n  dy_yrs &lt;- ifelse((year %% 4 == 0 & year %% 100 != 0) | (year %% 400 == 0), 366,365.25)\n#&gt; Get the time components\n  hour &lt;- POSIX_date$hour\n  minute &lt;- POSIX_date$min\n  second &lt;- POSIX_date$sec\n#&gt; Calculate the fraction of the day\n  fraction_day &lt;- (hour * 3600 + minute * 60 + second) / (86400)\n  dex_date &lt;- year + (day -1 + fraction_day)/dy_yrs\n  return(dex_date)\n}\n\n#&gt; Let's test it\ntest &lt;- dex.date(\"2027/2/19 23:30:45\")\nprint(test)\n#&gt; [1] 2027.13684\n\nAlright! The function is accurate up to the fourth significant figure6 That‚Äôs great, but now I have to create a second function to convert from JDE to Gregorian time. I‚Äôll use October 15, 1582 as the first day in the Gregorian calendar, which means that the number of Julian days from 4,713 BC to Oct.¬†15, 1582 is \\(2299161.05\\)\n6¬†We can test this by using the decimal_date function in the lubridate package. We get 2027.1369.\nconvert.JDE &lt;- function(jde){\n  jde &lt;- jde + 0.5\n  Z &lt;- trunc(jde)\n  F &lt;- jde - Z\n  if (Z &lt; 2299161) {\n    A &lt;- Z\n  } else {\n    alpha &lt;- trunc((Z - 1867216.25) / 36524.25)\n    A &lt;- Z + 1 + alpha - trunc(alpha / 4)\n  }\n  B &lt;- A + 1524\n  C &lt;- trunc((B - 122.1) / 365.25)\n  D &lt;- trunc(365.25 * C)\n  E &lt;- trunc((B - D) / 30.6001)\n\n  day &lt;- B - D - trunc(30.6001 * E) + F\n  month &lt;- ifelse(E &lt; 14, E - 1, E - 13)\n  year &lt;- ifelse(month &gt; 2, C - 4716, C - 4715)\n\n  # Extract the fractional day part for time\n  hour &lt;- (day - trunc(day)) * 24\n  minute &lt;- (hour - trunc(hour)) * 60\n  second &lt;- (minute - trunc(minute)) * 60\n  \n  # Create a POSIXlt object for the Gregorian date and time\n  gregorian_date &lt;- as.POSIXlt(sprintf(\"%04d-%02d-%02d %02d:%02d:%06.3f\",\n                                       year, month, trunc(day),\n                                       trunc(hour), trunc(minute), second),\n                               format = \"%Y-%m-%d %H:%M:%OS\", tz = \"UTC\")\n  return(gregorian_date)\n}\n\nAfter checking the accuracy of the convert.JDE function by using the following examples, we can create a third function to convert from Gregorian time to JDE. This is extra work, but it assures us that our JDE calculation is accurate and error-freeü§û\n\n\n\nDates for testing JDE conversion function\n\nCalendar\nJDE\n\n\n\n2000/01/01 12:00:00\n2451545.0\n\n\n1999/01/01\n2451179.5\n\n\n1600/01/01\n2305447.5\n\n\n837/04/10 7:12:00\n2026871.8\n\n\n1987/06/19 12:00:00\n2446966.0\n\n\n1900/01/01\n2415020.5\n\n\n\n\n\nThe JDE function we created cannot be used here because the variable \\(k\\) is not needed for calendar transformation. If we were to use it, we would always get a Julian date that‚Äôs off by 1 - 7 days‚Ä¶I‚Äôve already tried it.\n\ngreg.convert&lt;- function(date){\n  if (!inherits(date, c(\"POSIXt\", \"POSIXct\", \"POSIXlt\", \"Date\"))) {\n    #&gt; Transform to POSIXlt\n  POSIX_date &lt;- as.POSIXlt(date)\n  }\n  Y &lt;- POSIX_date$year + 1900\n  M &lt;- POSIX_date$mon + 1\n  D &lt;- POSIX_date$mday\n  H &lt;- POSIX_date$hour\n  mn &lt;- POSIX_date$min\n  S &lt;- POSIX_date$sec\n  Y_up &lt;- ifelse(M &gt; 2, Y,Y - 1)\n  M_up &lt;- ifelse(M &gt; 2,M, M + 12)\n  A &lt;- floor(Y_up/100)\n  if(Y_up &lt; 1582){ # If looking at Julian calendar\n    B = 0\n  } else{\n    B = 2 - A + floor(A/4)\n  }\n  D_dec &lt;- (H + mn/60 + S/3600)/24\n  jde &lt;- floor(365.25*(Y_up + 4716)) + floor(30.6001*(M_up +1)) + D + D_dec + B - 1524.5\n  return(jde)\n}\ntesty &lt;- greg.convert(\"2027/02/19 23:30:45, tz = UTC\")\nprint(testy)\n#&gt; [1] 2461456.48\n\nWe can use the Dates table to test the accuracy of this function. One example that caught my attention is the date 3837-04-10 07:12:00. This particular date returned \\(3122594.8\\) and the convert.JDE function was 3837-04-10 07:11:60 EDT, which made me think that it was a day with a leap second, but those are unpredictable and not known so far in advance. We‚Äôll have to deal with this error as well.\n\nWith all the parts in place, we can get back to writing the main function. Ideally, a date will be entered, we will calculate \\(k\\), then \\(T\\) to obtain the JDE date which, by the way, is not accurately representing the date of the chosen lunar phase yet. Our algorithm will them find \\(E, M, M^\\prime, F\\), and \\(\\Omega\\). The fourteen planetary corrections will be applied next, and additional correction for the selected lunar phase will be calculated. We‚Äôll then use these corrections to adjust the JDE date and finally convert it to the Gregorian date using the convert.JDE function. We can check the accuracy of our results by using the greg.convert function. Here we go:\n\ncalc.MoonPhase &lt;- function(k){\n  stopifnot(is.numeric(k))\n  \n  t &lt;- k / 1236.85\n  \n  # Mean phase JDE\n  jde &lt;- JDE(k, t)\n  \n  # Anomaly, latitude, and longitude of Sun/Moon\n  e &lt;- E(k, t)\n  m &lt;- M(k, t)\n  mpr &lt;- M.prime(k, t)\n  f &lt;- F(k, t)\n  om &lt;- omega(k, t)\n  \n  kfrac &lt;- modf(k)[2]\n  kint &lt;- modf(k)[1]\n  \n  planet_args &lt;- (\n    0.000325 * sin(A1(k, t)) + \n    0.000165 * sin(A2(k)) + \n    0.000164 * sin(A3(k)) +\n    0.000126 * sin(A4(k)) + \n    0.000110 * sin(A5(k)) + \n    0.000062 * sin(A6(k)) +\n    0.000060 * sin(A7(k)) + \n    0.000056 * sin(A8(k)) + \n    0.000047 * sin(A9(k)) +\n    0.000042 * sin(A10(k)) + \n    0.000040 * sin(A11(k)) + \n    0.000037 * sin(A12(k)) +\n    0.000035 * sin(A13(k)) + \n    0.000023 * sin(A14(k))\n  )\n  \n  if (kfrac == 0) {\n    adj &lt;- (\n      -0.40720 * sin(mpr) + \n      0.17241 * e * sin(m) + \n      0.01608 * sin(2 * mpr) + \n      0.01039 * sin(2 * f) + \n      0.00739 * e * sin(mpr - m) - \n      0.00514 * e * sin(mpr + m) +\n      0.00208 * (e^2) * sin(2 * m) - \n      0.00111 * sin(mpr - 2 * f) - \n      0.00057 * sin(mpr + 2 * f) +\n      0.00056 * e * sin(2 * mpr + m) - \n      0.00042 * sin(3 * mpr) + \n      0.00042 * e * sin(m + 2 * f) +\n      0.00038 * e * sin(m - 2 * f) - \n      0.00024 * e * sin(2 * mpr - m) - \n      0.00017 * sin(om) -\n      0.00007 * sin(mpr + 2 * m) + \n      0.00004 * sin(2 * mpr - 2 * f) + \n      0.00004 * sin(3 * m) +\n      0.00003 * sin(mpr + m - 2 * f) + \n      0.00003 * sin(2 * mpr + 2 * f) - \n      0.00003 * sin(mpr + m + 2 * f) +\n      0.00003 * sin(mpr - m + 2 * f) - \n      0.00002 * sin(mpr - m - 2 * f) - \n      0.00002 * sin(3 * mpr + m) +\n      0.00002 * sin(4 * mpr)\n      )\n    \n    true_jde &lt;- (jde + adj) + planet_args\n     true_date &lt;- convert.JDE(true_jde)\n  return(true_date)\n    \n  } else if (kfrac == .25 || kfrac == .75) {\n    adj2 &lt;- (\n      -0.62801 * sin(mpr) + \n      0.17172 * e * sin(m) - \n      0.01183 * e * sin(mpr + m) + \n      0.00862 * sin(2 * mpr) + \n      0.00804 * sin(2 * f) + \n      0.00454 * e * sin(mpr - m) + \n      0.00204 * (e^2) * sin(2 * m) - \n      0.00180 * sin(mpr - 2 * f) - \n      0.00070 * sin(mpr + 2 * f) -\n      0.00040 * sin(3 * mpr) - \n      0.00034 * e * sin(2 * mpr - m) + \n      0.00032 * e * sin(m + 2 * f) + \n      0.00032 * e * sin(m - 2 * f) - \n      0.00028 * (e^2) * sin(mpr + 2 * m) + \n      0.00027 * e * sin(2 * mpr + m) - \n      0.00017 * sin(om) - \n      0.00005 * sin(mpr - m - 2 * f) + \n      0.00004 * sin(2 * mpr + 2 * f) - \n      0.00004 * sin(mpr + m + 2 * f) + \n      0.00004 * sin(mpr - 2 * m) + \n      0.00003 * sin(mpr + m - 2 * f) + \n      0.00003 * sin(3 * m) + \n      0.00002 * sin(2 * mpr - 2 * f) + \n      0.00002 * sin(mpr - m + 2 * f) - \n      0.00002 * sin(3 * mpr + m)\n      )\n    \n    w &lt;- (\n      0.00306 - 0.00038 * e * cos(m) + \n      0.00026 * cos(mpr) - \n      0.00002 * cos(mpr - m) +\n         0.00002 * cos(mpr + m) +\n      0.00002 * cos(2 * f)\n    )\n    \n    if (kfrac == .25) {\n      if(kint &gt; 0){\n        true_jde &lt;- (jde + adj2) + w + planet_args\n      } else {  # First Quarter before 2000 AD\n        true_jde &lt;- (jde + adj2) - w + planet_args\n      }\n    } else {  # kfrac == 0.75\n    if (kint &gt; 0) {  # Last Quarter after 2000 AD\n        true_jde &lt;- (jde + adj2) - w + planet_args\n      } else {  # Last Quarter before 2000 AD\n        true_jde &lt;- (jde + adj2) + w + planet_args\n      }\n    }\n    true_date &lt;- convert.JDE(true_jde)\n    return(true_date)\n    \n  } else if (kfrac == .5) {\n    adj3 &lt;- (\n      -0.40614 * sin(mpr) + \n      0.17302 * e * sin(m) + \n      0.01614 * sin(2 * mpr) + \n            0.01043 * sin(2 * f) + \n      0.00734 * e * sin(mpr - m) - \n      0.00514 * e * sin(mpr + m) + \n            0.00209 * (e^2) * sin(2 * m) - \n      0.00111 * sin(mpr - 2 * f) - \n      0.00057 * sin(mpr + 2 * f) + \n            0.00056 * e * sin(2 * mpr + m) - \n      0.00042 * sin(3 * mpr) + \n      0.00042 * e * sin(m + 2 * f) + \n            0.00038 * e * sin(m - 2 * f) - \n      0.00024 * e * sin(2 * mpr - m) - \n      0.00017 * sin(om) - \n            0.00007 * sin(mpr + 2 * m) + \n      0.00004 * sin(2 * mpr - 2 * f) + \n      0.00004 * sin(3 * m) + \n            0.00003 * sin(mpr + m - 2 * f) + \n      0.00003 * sin(2 * mpr + 2 * f) - \n      0.00003 * sin(mpr + m + 2 * f) + \n            0.00003 * sin(mpr - m + 2 * f) -\n      0.00002 * sin(mpr - m - 2 * f) - \n            0.00002 * sin(3 * mpr + m) + \n      0.00002 * sin(4 * mpr)\n      )\n    \n    true_jde &lt;- (jde + adj3) + planet_args\n    true_date &lt;- convert.JDE(true_jde)\n  return(true_date)\n    \n  } else if (kfrac &gt; 0 && kfrac &lt; .25) {\n    return(cat(\"Moon is in Waxing Crescent Phase. No valid date returned\"))\n  } else if (kfrac &gt; .25 && kfrac &lt; .5) {\n    return(cat(\"Moon is in Waxing Gibbous Phase. No valid date returned\"))\n  } else if (kfrac &gt; .5 && kfrac &lt; .75) {\n    return(cat(\"Moon is in Waning Gibbous Phase. No valid date returned\"))\n  } else {\n    return(cat(\"Moon is in Waning Crescent Phase. No valid date returned\"))\n  }\n}\n\nWe can test the function using a few examples of past, present and future lunar phases. We‚Äôll use dex.date to convert the year to decimal format before finding \\(k\\). Once we find the value of \\(k\\), we‚Äôll round up or down depending on the moon phase7 we‚Äôre trying to estimate. There should be a small discrepancy between actual and predicted lunar phase dates because:\n7¬†\\(k = 0\\) for the new moon, \\(k = .25\\) for first quarter, \\(k = .50\\) for full moon and \\(k = .75\\) for the last quarter.\nWe‚Äôve ignored several arguments and corrections.\nThe U.S Naval Observatory doesn‚Äôt include seconds in their date and time estimates.\nFuture dates estimates are as accurate as the amazing,but fallible algorithms that predicted them.\nThere are no high precision records of the orbital positions of the sun and the moon prior to the invention of the telescope in 1609 A.D.\n\n\n\n\n\n\n\nImportant\n\n\n\nIn the interest of space, I‚Äôve hidden the data generation code. You can download a .txt version of it here if you‚Äôd like to follow along. -  USN Dates\n\n\n\nCode for generating test dates for calc.MoonPhaseUSN_dates &lt;- data.frame(Dates = c(\n\"1930/01/08 03:11:00\",\n\"1930/01/14 22:21:00\",\n\"1930/01/21 16:07:00\",\n\"1930/01/29 19:07:00\",\n\"1930/11/28 06:18:00\",\n\"1930/12/06 00:40:00\",\n\"1930/12/12 20:07:00\",\n\"1930/12/20 01:24:00\",\n\"1971/03/04 02:01:00\",\n\"1971/03/12 02:34:00\",\n\"1971/03/20 02:30:00\",\n\"1971/05/24 12:32:00\",\n\"1971/09/27 17:17:00\",\n\"1971/10/04 12:19:00\",\n\"1971/10/11 05:29:00\",\n\"1971/12/17 19:03:00\",\n\"1701/01/17 09:42:00\",\n\"1701/01/24 12:52:00\",\n\"1701/01/31 04:21:00\",\n\"1701/02/07 22:57:00\",\n\"1701/11/07 12:03:00\",\n\"1701/11/15 16:53:00\",\n\"1701/11/23 06:09:00\",\n\"1701/11/29 21:53:00\",\n\"2010/09/15 05:50:00\",\n\"2010/09/23 09:17:00\",\n\"2010/10/01 03:52:00\",\n\"2010/10/07 18:44:00\",\n\"2010/11/13 16:39:00\",\n\"2010/11/21 17:27:00\",\n\"2010/11/28 20:36:00\",\n\"2010/12/05 17:36:00\",\n\"2023/04/27 21:20:00\",\n\"2023/05/05 17:34:00\",\n\"2023/05/12 14:28:00\",\n\"2023/05/19 15:53:00\",\n\"2023/08/24 09:57:00\",\n\"2023/08/31 01:35:00\",\n\"2023/09/06 22:21:00\",\n\"2023/09/15 01:40:00\",\n\"2072/01/28 10:36:00\",\n\"2072/02/04 04:56:00\",\n\"2072/02/10 23:27:00\",\n\"2072/02/19 02:04:00\",\n\"2100/01/18 12:35:00\",\n\"2100/01/26 02:51:00\",\n\"2100/02/01 21:17:00\",\n\"2100/02/09 04:56:00\",\n\"1833/03/28 22:50:00\",\n\"1833/04/04 14:43:00\",\n\"1833/04/12 00:09:00\",\n\"1833/05/19 13:36:00\"),\n                        Phases = rep(c(\n\"First Quarter\", \"Full Moon\", \"Last Quarter\", \"New Moon\"),13)\n)\n#&gt; file_path &lt;- here::here(\"06\",\"moon\",\"USN_dates.txt\")\n#&gt; write.table(USN_dates, file = file_path, sep = \"\\t\", col.names = TRUE)\n\n\nHowever, the lunar phase estimates are not too far off from the observed dates. Let‚Äôs find out how accurate our function really is by calculating the mean prediction error for a bigger set of dates taken from the U.S Naval Observatory\n\n\n\nMean error of time difference (in mins) between predicted and actual dates\n\nYear\nFirst Quarter\nFull Moon\nLast Quarter\nNew Moon\n\n\n\n1701\n0.920\n0.930\n0.330\n0.200\n\n\n1833\n0.380\n0.560\n0.010\n0.290\n\n\n1930\n0.220\n0.310\n0.265\n0.610\n\n\n1971\n0.700\n0.550\n0.590\n0.275\n\n\n2010\n0.465\n1.150\n1.150\n0.955\n\n\n2023\n1.350\n1.565\n1.475\n1.305\n\n\n2072\n2.090\n1.640\n1.950\n1.720\n\n\n2100\n1.920\n1.830\n2.120\n2.070\n\n\n\n\n\nVisualizing it may provide a different perspective on the time discrepancy between the actual and the predicted dates of the lunar phases. We can see how the algorithm is more accurate as we reach the present and loses accuracy as we move away from it.\n\n\n\n\n\n\n\n\n\nFinally, we can accurately predict when the werewolves will turn üê∫, just kidding!\nIn all seriousness, the calc.MoonPhase function is accurate to within 2 minutes for a period of 400 years, but deteriorates as the time interval increases8. So, if an error of a few minutes is not important, we may use the algorithm to accurately predict the date of any lunar phase. However, we must also keep in mind that there will always be a small prediction error in every algorithm because the time interval between consecutive lunations will vary as the Sun perturbs the lunar path, and we cannot account for every force or action exerted on our ‚Äúlittle‚Äù satellite.\n\n\n\n\n8¬†the time difference in the expected date and the official date for the full moon of 0033/04/03 is 2 hrs, 50 mins and 24 seconds."
  },
  {
    "objectID": "blog/2024/06/moon/index.html#monthly-changes-in-her-circle-orb",
    "href": "blog/2024/06/moon/index.html#monthly-changes-in-her-circle-orb",
    "title": "swear not by the moon, the fickle moon",
    "section": "",
    "text": "Tip\n\n\n\nIf you‚Äôre wondering where I‚Äôm getting my titles and headings, they come from Shakespeare‚Äôs sonnets.\n\n\nThe moon has always fascinated me. Eversince I was a child, I was entranced by it; her constant pursuit everywhere I went and her sneaky tactics during the day. This year, before the solar eclipse, I decided to do a little digging and replicate one algorithm used to determine the phases of the moon. If you‚Äôre interested, you can find it here in this very dense book by Jean Meeus.\nIn case you didn‚Äôt know, the times of the new moon, first quarter, full moon, and last quarter are the times at which the moon‚Äôs longitude, as viewed from our planet, aligns with the sun to form 0\\(^\\circ\\), 90\\(^\\circ\\), 180\\(^\\circ\\), and 270\\(^\\circ\\), respectively. As the moon orbits the earth and rotates on its axis, it overlaps with the Sun in varying degrees, and thus light is reflected off of it. This means that to calculate the phases of the moon, we would technically need to know the geocentric1 longitude of the Moon and the Sun‚Ä¶and I‚Äôm not doing thatüôÉ so giving up a sliver of accuracy seems the right solution if we want to avoid an unorthodox amount of math.\n1¬†as viewed from the Earth\nAstronomers use Julian Ephemeris Days (JDE), or Dynamical Time (DT), as a measure of time to keep track of celestial bodies, and you probably guessed that its name may be derived from emperor Julius Caesar‚Äôs reform to create a calendar that always remained aligned to the sun, but that would be incorrect. It has nothing to do with Brutus‚Äôs uncle.\nThe first year under this calendar is Jan 1, 4,713 BC, which means that 2024 would represent the year 6737 of the Julian era‚Äîa pretty nerdy thing to point out, but nobody is complaininng, probably.\nTo find the JDE for any celestial event, we simply subtract 2,451,550 days from Ephemeris Time2, which is the number of days from 4713 BC to 1952‚Ä¶don‚Äôt quote me on thatüòÖ\n2¬†adopted in 1952The times of the mean phases of the moon are then given by:\n\\[\nJDE = 2,451,550.09766 + 29.530588861 k \\\\\n+ 0.00015437 T^{2} \\\\\n- 0.000000150 T^{3} \\\\\n+ 0.00000000073 T^{4}\n\\]\nwhere an integer value of \\(k = 0\\) gives a new moon3, and an increase by .25 gives the next phase, 1st quarter, full moon, and the third or last quarter. Any other value of \\(k\\) is meaningless.\n3¬†\\(k = 0\\) corresponds to the new moon of Jan 6, 2000, and negative values of \\(k\\) are lunar phases before the year 2000.\nThe approximate value of \\(k \\approx (year - 2000) √ó 12.3685\\) and the \\(year\\) variable should be expressed in decimals to include the month and day of the year. \\(T\\) is the time in Julian centuries since 2000, and we can accurately calculate it using this formula \\((\\frac{k}{1236.85})\\), and a term we haven‚Äôt seen yet, \\(E = 1 - 0.002516T - 0.0000074T^{2}\\) that describes the eccentricity of Earth‚Äôs orbit around the sun.\nThe angles for the sun‚Äôs and the moon‚Äôs mean anomaly4, the moon‚Äôs latitude and the longitude of the ascending node5 of the lunar orbit will also be calculated.\n4¬†distance from the center of the moon/sun measured from the side that is closest to earth assuming movement at a uniform speed in a circular orbit.5¬†the moon has an ascending and descending node where it crosses the ecliptic hemisphere from the south or the north, respectively.We need to take into account 14 planetary arguments and specific angles and time corrections for each phase of the moon to obtain any past, future and current Julian epochs. First, I‚Äôll create a simple function modf that will split an object of type double into its integer and decimal parts. I‚Äôll use this function to figure out the moon phase later down the road. A second function modr will reduce any angle to the range between 0‚Äì360, and a third function deg2rad will convert the degrees to radians, if necessary.\n\nCode for helper functions#&gt; Modulus fraction function\nmodf &lt;- function(k){\n     stopifnot(is.numeric(k))\n     kint &lt;- trunc(k)\n     kfrac &lt;- abs(k - kint)\n     kround &lt;- c(kint,kfrac)\n     return(kround)\n}\n\n#&gt; Modulus reduce angle function\nmodr &lt;- function(angle){\n  stopifnot(is.numeric(angle))\n  reduced &lt;- angle%%360\n  return(reduced)\n}\n\nrad2deg &lt;- function(rad){\n  stopifnot(is.numeric(rad))\n  degrees &lt;- (rad*180)/(pi)\n  return(degrees)\n}\n\ndeg2rad &lt;- function(deg){\n  stopifnot(is.numeric(deg))\n  radians &lt;- (deg*pi)/180\n  return(radians)\n}\n\ntest_it &lt;- modf(-3.35)\ntest &lt;- modr(400)\nprint(c(test_it,test))\n#&gt; [1] -3.00  0.35 40.00\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAlmost every function used here except the main function, modf,modr,deg2rad, rad2deg, and the dex.date functions are taken from Jean Meeus‚Äô ‚ÄúAstronomical Algorithms‚Äù.\n\n\nThe goal is to calculate the date of any lunar phase any number of years into the future. To do this, we‚Äôll first create functions for the mean anomaly, latitude, and longitude of the moon.\n\n#&gt; Times of lunar phases in JDE\nJDE &lt;- function(k,t){\n jde &lt;- 2451550.09766 + (29.530588861*k) + \n   0.00015437*(t^2) - 0.000000150*(t^3) + \n   0.00000000073*(t^4)\n jde &lt;- round(jde,digits = 6)\n return(jde)\n}\n#&gt; Calculate E\nE &lt;- function(k,t){\n  e &lt;- 1 - (0.002516*t) - 0.0000074*(t^2)\n  e &lt;- round(e,digits = 6)\n  return(e)\n}\n\n#&gt; Sun's mean anomaly at time JDE\nM &lt;- function(k,t){\n  m &lt;- 2.5534 + (29.10535670*k) - 0.0000014*(t^2) - 0.00000011*(t^3)\n  m &lt;- modr(round(m, digits = 6))\n  m &lt;- deg2rad(m)\n  return(m)\n}\n#&gt; Moon‚Äôs mean anomaly at time JDE\nM.prime &lt;- function(k,t){\n  m_prime &lt;- 201.5643 + (385.81693528*k) + 0.0107582*(t^2) + \n    0.00001238*(t^3) - 0.000000058*(t^4)\n  m_prime &lt;- modr(round(m_prime,digits = 6))\n  m_prime &lt;- deg2rad(m_prime)\n  return(m_prime)\n}\n#&gt; Moon's argument of latitude\nF &lt;- function(k,t){\n  f &lt;- 160.7108 + (390.67050284*k) - 0.0016118*(t^2) - \n    0.00000227*(t^3) + 0.000000011*(t^4)\n  f &lt;- modr(round(f, digits = 6))\n  f &lt;- deg2rad(f)\n  return(f)\n}\n\nomega &lt;- function(k,t){\n  o &lt;- 124.7746 - (1.56375588*k) + 0.0020672*(t^2) + 0.00000215*(t^3)\n  o &lt;- modr(round(0, digits = 6))\n  o &lt;- deg2rad(o)\n  return(o)\n}\n\nNow it‚Äôs time to come up with a function fo each planetary argument (14 total). Most of these argument take \\(k\\) with one exception \\(A_{1}\\), which also requires \\(T\\). The output of the planetary arguments are expressed in degrees and may have to be reduced to 0‚Äì360 and converted to radians. Since our main function does use every planetary argument to predict the lunar phases it may be better to provide the arguments as functions instead of vectors. if doing this is too torublesome, we‚Äôll try something different inside the main function.\n\nPlanetary Arguments functionsA1 &lt;- function(k,t){\n  a1 &lt;- 299.77 + 0.107408*k - 0.009173*(t^2)\n  a1 &lt;- modr(round(a1, digits = 6))\n  a1 &lt;- deg2rad(a1)\n  return(a1)\n}\nA2 &lt;- function(k){\n  a2 &lt;- 251.88 + 0.016321*k\n  a2 &lt;- modr(round(a2,digits = 6))\n  a2 &lt;- deg2rad(a2)\n  return(a2)\n}\nA3 &lt;- function(k){\n  a3 &lt;- 251.83 + 26.651886*k\n  a3 &lt;- modr(round(a3,digits = 6))\n  a3 &lt;- deg2rad(a3)\n  return(a3)\n}\n\nA4 &lt;- function(k){\n  a4 &lt;- 349.42 + 36.412478*k\n  a4 &lt;- modr(round(a4,digits = 6))\n  a4 &lt;- deg2rad(a4)\n  return(a4)\n}\nA5 &lt;- function(k){\n  a5 &lt;- 84.66 + 18.206239*k\n  a5 &lt;- modr(round(a5, digits = 6))\n  a5 &lt;- deg2rad(a5)\n  return(a5)\n}\nA6 &lt;- function(k){\n  a6 &lt;- 141.74 + 53.303771*k\n  a6 &lt;- modr(round(a6,digits = 6))\n  a6 &lt;- deg2rad(a6)\n  return(a6)\n}\nA7 &lt;- function(k){\n  a7 &lt;- 207.14 + 2.453732*k\n  a7 &lt;- modr(round(a7, digits = 6))\n  a7 &lt;- deg2rad(a7)\n  return(a7)\n}\nA8 &lt;- function(k){\n  a8 &lt;- 154.84 + 7.306860*k\n  a8 &lt;- modr(round(a8,digits = 6))\n  a8 &lt;- deg2rad(a8)\n  return(a8)\n}\nA9 &lt;- function(k){\n  a9 &lt;- 34.52 + 27.261239*k\n  a9 &lt;- modr(round(a9,digits = 6))\n  a9 &lt;- deg2rad(a9)\n  return(a9)\n}\nA10 &lt;- function(k){\n  a10 &lt;- 207.19 + 0.121824*k\n  a10 &lt;- modr(round(a10, digits = 6))\n  a10 &lt;- deg2rad(a10)\n  return(a10)\n}\nA11 &lt;- function(k){\n  a11 &lt;- 291.34 + 1.844379*k\n  a11 &lt;- modr(round(a11,digits = 6))\n  a11 &lt;- deg2rad(a11)\n  return(a11)\n}\nA12 &lt;- function(k){\n  a12 &lt;- 161.72 + 24.198154*k\n  a12 &lt;- modr(round(a12,digits = 6))\n  a12 &lt;- deg2rad(a12)\n  return(a12)\n}\nA13 &lt;- function(k){\n  a13 &lt;- 239.56 + 25.513099*k\n  a13 &lt;- modr(round(a13,digits = 6))\n  a13 &lt;- deg2rad(a13)\n  return(a13)\n}\nA14 &lt;- function(k){\n  a14 &lt;- 331.55 + 3.592518*k\n  a14 &lt;- modr(round(a14, digits = 6))\n  a14 &lt;- deg2rad(a14)\n  return(a14)\n}\n\n\n\nUsing the preciously coded functions, we‚Äôll create the main function with and add conditions for each moon phase to accurately implement the time corrections.\nSomething to keep in mind is that the date variable will have to be expressed as a decimal for the algorithm to work. This means that I‚Äôll have to transform the date outside the main function before doing any computations.\nThe output will be in date format so we‚Äôll need to look at R‚Äôs date manipulation capabilities. The built.in as.Date function won‚Äôt work for us because it doesn‚Äôt handle time (HH:MM:SS), so we‚Äôre left with two choices, the chron package which handles time but doesn‚Äôt account for timezones or the built.in POSIX classes that do manipulate timezones. I‚Äôm going with POSIXlt so that I can extract time information without pulling from external libraries.\n\nI‚Äôll test a simple function to transform a character string in the format \"YYYY/MM/DD\" to a POSIXlt date and then return a decimal to represent the number of days completed in any given year.\nSomething to note: Some years will be leap or century years, and this will also have to be dealt with. Additionally, we‚Äôre calculating the number of days completed up to the current date, which means we‚Äôll update our function to use day - 1 to find the decimal expression for the specified date.\n\ndex.date &lt;- function(date){\n  if (!inherits(date, c(\"POSIXt\", \"POSIXct\", \"POSIXlt\", \"Date\"))) {\n    #&gt; Transform to POSIXlt\n  POSIX_date &lt;- as.POSIXlt(date)\n#&gt; if the format is not found by the function, you can provide                                    \n#&gt; your format explicitly.\n  }\n  year &lt;- POSIX_date$year + 1900 \n#&gt; Pull the year attribute and add 1900, default is to subtract                                   \n#&gt; 1900 to provided year\n  day &lt;- as.numeric(format(POSIX_date,\"%j\")) # day of the year 0 - 365\n  dy_yrs &lt;- ifelse((year %% 4 == 0 & year %% 100 != 0) | (year %% 400 == 0), 366,365.25)\n#&gt; Get the time components\n  hour &lt;- POSIX_date$hour\n  minute &lt;- POSIX_date$min\n  second &lt;- POSIX_date$sec\n#&gt; Calculate the fraction of the day\n  fraction_day &lt;- (hour * 3600 + minute * 60 + second) / (86400)\n  dex_date &lt;- year + (day -1 + fraction_day)/dy_yrs\n  return(dex_date)\n}\n\n#&gt; Let's test it\ntest &lt;- dex.date(\"2027/2/19 23:30:45\")\nprint(test)\n#&gt; [1] 2027.13684\n\nAlright! The function is accurate up to the fourth significant figure6 That‚Äôs great, but now I have to create a second function to convert from JDE to Gregorian time. I‚Äôll use October 15, 1582 as the first day in the Gregorian calendar, which means that the number of Julian days from 4,713 BC to Oct.¬†15, 1582 is \\(2299161.05\\)\n6¬†We can test this by using the decimal_date function in the lubridate package. We get 2027.1369.\nconvert.JDE &lt;- function(jde){\n  jde &lt;- jde + 0.5\n  Z &lt;- trunc(jde)\n  F &lt;- jde - Z\n  if (Z &lt; 2299161) {\n    A &lt;- Z\n  } else {\n    alpha &lt;- trunc((Z - 1867216.25) / 36524.25)\n    A &lt;- Z + 1 + alpha - trunc(alpha / 4)\n  }\n  B &lt;- A + 1524\n  C &lt;- trunc((B - 122.1) / 365.25)\n  D &lt;- trunc(365.25 * C)\n  E &lt;- trunc((B - D) / 30.6001)\n\n  day &lt;- B - D - trunc(30.6001 * E) + F\n  month &lt;- ifelse(E &lt; 14, E - 1, E - 13)\n  year &lt;- ifelse(month &gt; 2, C - 4716, C - 4715)\n\n  # Extract the fractional day part for time\n  hour &lt;- (day - trunc(day)) * 24\n  minute &lt;- (hour - trunc(hour)) * 60\n  second &lt;- (minute - trunc(minute)) * 60\n  \n  # Create a POSIXlt object for the Gregorian date and time\n  gregorian_date &lt;- as.POSIXlt(sprintf(\"%04d-%02d-%02d %02d:%02d:%06.3f\",\n                                       year, month, trunc(day),\n                                       trunc(hour), trunc(minute), second),\n                               format = \"%Y-%m-%d %H:%M:%OS\", tz = \"UTC\")\n  return(gregorian_date)\n}\n\nAfter checking the accuracy of the convert.JDE function by using the following examples, we can create a third function to convert from Gregorian time to JDE. This is extra work, but it assures us that our JDE calculation is accurate and error-freeü§û\n\n\n\nDates for testing JDE conversion function\n\nCalendar\nJDE\n\n\n\n2000/01/01 12:00:00\n2451545.0\n\n\n1999/01/01\n2451179.5\n\n\n1600/01/01\n2305447.5\n\n\n837/04/10 7:12:00\n2026871.8\n\n\n1987/06/19 12:00:00\n2446966.0\n\n\n1900/01/01\n2415020.5\n\n\n\n\n\nThe JDE function we created cannot be used here because the variable \\(k\\) is not needed for calendar transformation. If we were to use it, we would always get a Julian date that‚Äôs off by 1 - 7 days‚Ä¶I‚Äôve already tried it.\n\ngreg.convert&lt;- function(date){\n  if (!inherits(date, c(\"POSIXt\", \"POSIXct\", \"POSIXlt\", \"Date\"))) {\n    #&gt; Transform to POSIXlt\n  POSIX_date &lt;- as.POSIXlt(date)\n  }\n  Y &lt;- POSIX_date$year + 1900\n  M &lt;- POSIX_date$mon + 1\n  D &lt;- POSIX_date$mday\n  H &lt;- POSIX_date$hour\n  mn &lt;- POSIX_date$min\n  S &lt;- POSIX_date$sec\n  Y_up &lt;- ifelse(M &gt; 2, Y,Y - 1)\n  M_up &lt;- ifelse(M &gt; 2,M, M + 12)\n  A &lt;- floor(Y_up/100)\n  if(Y_up &lt; 1582){ # If looking at Julian calendar\n    B = 0\n  } else{\n    B = 2 - A + floor(A/4)\n  }\n  D_dec &lt;- (H + mn/60 + S/3600)/24\n  jde &lt;- floor(365.25*(Y_up + 4716)) + floor(30.6001*(M_up +1)) + D + D_dec + B - 1524.5\n  return(jde)\n}\ntesty &lt;- greg.convert(\"2027/02/19 23:30:45, tz = UTC\")\nprint(testy)\n#&gt; [1] 2461456.48\n\nWe can use the Dates table to test the accuracy of this function. One example that caught my attention is the date 3837-04-10 07:12:00. This particular date returned \\(3122594.8\\) and the convert.JDE function was 3837-04-10 07:11:60 EDT, which made me think that it was a day with a leap second, but those are unpredictable and not known so far in advance. We‚Äôll have to deal with this error as well.\n\nWith all the parts in place, we can get back to writing the main function. Ideally, a date will be entered, we will calculate \\(k\\), then \\(T\\) to obtain the JDE date which, by the way, is not accurately representing the date of the chosen lunar phase yet. Our algorithm will them find \\(E, M, M^\\prime, F\\), and \\(\\Omega\\). The fourteen planetary corrections will be applied next, and additional correction for the selected lunar phase will be calculated. We‚Äôll then use these corrections to adjust the JDE date and finally convert it to the Gregorian date using the convert.JDE function. We can check the accuracy of our results by using the greg.convert function. Here we go:\n\ncalc.MoonPhase &lt;- function(k){\n  stopifnot(is.numeric(k))\n  \n  t &lt;- k / 1236.85\n  \n  # Mean phase JDE\n  jde &lt;- JDE(k, t)\n  \n  # Anomaly, latitude, and longitude of Sun/Moon\n  e &lt;- E(k, t)\n  m &lt;- M(k, t)\n  mpr &lt;- M.prime(k, t)\n  f &lt;- F(k, t)\n  om &lt;- omega(k, t)\n  \n  kfrac &lt;- modf(k)[2]\n  kint &lt;- modf(k)[1]\n  \n  planet_args &lt;- (\n    0.000325 * sin(A1(k, t)) + \n    0.000165 * sin(A2(k)) + \n    0.000164 * sin(A3(k)) +\n    0.000126 * sin(A4(k)) + \n    0.000110 * sin(A5(k)) + \n    0.000062 * sin(A6(k)) +\n    0.000060 * sin(A7(k)) + \n    0.000056 * sin(A8(k)) + \n    0.000047 * sin(A9(k)) +\n    0.000042 * sin(A10(k)) + \n    0.000040 * sin(A11(k)) + \n    0.000037 * sin(A12(k)) +\n    0.000035 * sin(A13(k)) + \n    0.000023 * sin(A14(k))\n  )\n  \n  if (kfrac == 0) {\n    adj &lt;- (\n      -0.40720 * sin(mpr) + \n      0.17241 * e * sin(m) + \n      0.01608 * sin(2 * mpr) + \n      0.01039 * sin(2 * f) + \n      0.00739 * e * sin(mpr - m) - \n      0.00514 * e * sin(mpr + m) +\n      0.00208 * (e^2) * sin(2 * m) - \n      0.00111 * sin(mpr - 2 * f) - \n      0.00057 * sin(mpr + 2 * f) +\n      0.00056 * e * sin(2 * mpr + m) - \n      0.00042 * sin(3 * mpr) + \n      0.00042 * e * sin(m + 2 * f) +\n      0.00038 * e * sin(m - 2 * f) - \n      0.00024 * e * sin(2 * mpr - m) - \n      0.00017 * sin(om) -\n      0.00007 * sin(mpr + 2 * m) + \n      0.00004 * sin(2 * mpr - 2 * f) + \n      0.00004 * sin(3 * m) +\n      0.00003 * sin(mpr + m - 2 * f) + \n      0.00003 * sin(2 * mpr + 2 * f) - \n      0.00003 * sin(mpr + m + 2 * f) +\n      0.00003 * sin(mpr - m + 2 * f) - \n      0.00002 * sin(mpr - m - 2 * f) - \n      0.00002 * sin(3 * mpr + m) +\n      0.00002 * sin(4 * mpr)\n      )\n    \n    true_jde &lt;- (jde + adj) + planet_args\n     true_date &lt;- convert.JDE(true_jde)\n  return(true_date)\n    \n  } else if (kfrac == .25 || kfrac == .75) {\n    adj2 &lt;- (\n      -0.62801 * sin(mpr) + \n      0.17172 * e * sin(m) - \n      0.01183 * e * sin(mpr + m) + \n      0.00862 * sin(2 * mpr) + \n      0.00804 * sin(2 * f) + \n      0.00454 * e * sin(mpr - m) + \n      0.00204 * (e^2) * sin(2 * m) - \n      0.00180 * sin(mpr - 2 * f) - \n      0.00070 * sin(mpr + 2 * f) -\n      0.00040 * sin(3 * mpr) - \n      0.00034 * e * sin(2 * mpr - m) + \n      0.00032 * e * sin(m + 2 * f) + \n      0.00032 * e * sin(m - 2 * f) - \n      0.00028 * (e^2) * sin(mpr + 2 * m) + \n      0.00027 * e * sin(2 * mpr + m) - \n      0.00017 * sin(om) - \n      0.00005 * sin(mpr - m - 2 * f) + \n      0.00004 * sin(2 * mpr + 2 * f) - \n      0.00004 * sin(mpr + m + 2 * f) + \n      0.00004 * sin(mpr - 2 * m) + \n      0.00003 * sin(mpr + m - 2 * f) + \n      0.00003 * sin(3 * m) + \n      0.00002 * sin(2 * mpr - 2 * f) + \n      0.00002 * sin(mpr - m + 2 * f) - \n      0.00002 * sin(3 * mpr + m)\n      )\n    \n    w &lt;- (\n      0.00306 - 0.00038 * e * cos(m) + \n      0.00026 * cos(mpr) - \n      0.00002 * cos(mpr - m) +\n         0.00002 * cos(mpr + m) +\n      0.00002 * cos(2 * f)\n    )\n    \n    if (kfrac == .25) {\n      if(kint &gt; 0){\n        true_jde &lt;- (jde + adj2) + w + planet_args\n      } else {  # First Quarter before 2000 AD\n        true_jde &lt;- (jde + adj2) - w + planet_args\n      }\n    } else {  # kfrac == 0.75\n    if (kint &gt; 0) {  # Last Quarter after 2000 AD\n        true_jde &lt;- (jde + adj2) - w + planet_args\n      } else {  # Last Quarter before 2000 AD\n        true_jde &lt;- (jde + adj2) + w + planet_args\n      }\n    }\n    true_date &lt;- convert.JDE(true_jde)\n    return(true_date)\n    \n  } else if (kfrac == .5) {\n    adj3 &lt;- (\n      -0.40614 * sin(mpr) + \n      0.17302 * e * sin(m) + \n      0.01614 * sin(2 * mpr) + \n            0.01043 * sin(2 * f) + \n      0.00734 * e * sin(mpr - m) - \n      0.00514 * e * sin(mpr + m) + \n            0.00209 * (e^2) * sin(2 * m) - \n      0.00111 * sin(mpr - 2 * f) - \n      0.00057 * sin(mpr + 2 * f) + \n            0.00056 * e * sin(2 * mpr + m) - \n      0.00042 * sin(3 * mpr) + \n      0.00042 * e * sin(m + 2 * f) + \n            0.00038 * e * sin(m - 2 * f) - \n      0.00024 * e * sin(2 * mpr - m) - \n      0.00017 * sin(om) - \n            0.00007 * sin(mpr + 2 * m) + \n      0.00004 * sin(2 * mpr - 2 * f) + \n      0.00004 * sin(3 * m) + \n            0.00003 * sin(mpr + m - 2 * f) + \n      0.00003 * sin(2 * mpr + 2 * f) - \n      0.00003 * sin(mpr + m + 2 * f) + \n            0.00003 * sin(mpr - m + 2 * f) -\n      0.00002 * sin(mpr - m - 2 * f) - \n            0.00002 * sin(3 * mpr + m) + \n      0.00002 * sin(4 * mpr)\n      )\n    \n    true_jde &lt;- (jde + adj3) + planet_args\n    true_date &lt;- convert.JDE(true_jde)\n  return(true_date)\n    \n  } else if (kfrac &gt; 0 && kfrac &lt; .25) {\n    return(cat(\"Moon is in Waxing Crescent Phase. No valid date returned\"))\n  } else if (kfrac &gt; .25 && kfrac &lt; .5) {\n    return(cat(\"Moon is in Waxing Gibbous Phase. No valid date returned\"))\n  } else if (kfrac &gt; .5 && kfrac &lt; .75) {\n    return(cat(\"Moon is in Waning Gibbous Phase. No valid date returned\"))\n  } else {\n    return(cat(\"Moon is in Waning Crescent Phase. No valid date returned\"))\n  }\n}\n\nWe can test the function using a few examples of past, present and future lunar phases. We‚Äôll use dex.date to convert the year to decimal format before finding \\(k\\). Once we find the value of \\(k\\), we‚Äôll round up or down depending on the moon phase7 we‚Äôre trying to estimate. There should be a small discrepancy between actual and predicted lunar phase dates because:\n7¬†\\(k = 0\\) for the new moon, \\(k = .25\\) for first quarter, \\(k = .50\\) for full moon and \\(k = .75\\) for the last quarter.\nWe‚Äôve ignored several arguments and corrections.\nThe U.S Naval Observatory doesn‚Äôt include seconds in their date and time estimates.\nFuture dates estimates are as accurate as the amazing,but fallible algorithms that predicted them.\nThere are no high precision records of the orbital positions of the sun and the moon prior to the invention of the telescope in 1609 A.D.\n\n\n\n\n\n\n\nImportant\n\n\n\nIn the interest of space, I‚Äôve hidden the data generation code. You can download a .txt version of it here if you‚Äôd like to follow along. -  USN Dates\n\n\n\nCode for generating test dates for calc.MoonPhaseUSN_dates &lt;- data.frame(Dates = c(\n\"1930/01/08 03:11:00\",\n\"1930/01/14 22:21:00\",\n\"1930/01/21 16:07:00\",\n\"1930/01/29 19:07:00\",\n\"1930/11/28 06:18:00\",\n\"1930/12/06 00:40:00\",\n\"1930/12/12 20:07:00\",\n\"1930/12/20 01:24:00\",\n\"1971/03/04 02:01:00\",\n\"1971/03/12 02:34:00\",\n\"1971/03/20 02:30:00\",\n\"1971/05/24 12:32:00\",\n\"1971/09/27 17:17:00\",\n\"1971/10/04 12:19:00\",\n\"1971/10/11 05:29:00\",\n\"1971/12/17 19:03:00\",\n\"1701/01/17 09:42:00\",\n\"1701/01/24 12:52:00\",\n\"1701/01/31 04:21:00\",\n\"1701/02/07 22:57:00\",\n\"1701/11/07 12:03:00\",\n\"1701/11/15 16:53:00\",\n\"1701/11/23 06:09:00\",\n\"1701/11/29 21:53:00\",\n\"2010/09/15 05:50:00\",\n\"2010/09/23 09:17:00\",\n\"2010/10/01 03:52:00\",\n\"2010/10/07 18:44:00\",\n\"2010/11/13 16:39:00\",\n\"2010/11/21 17:27:00\",\n\"2010/11/28 20:36:00\",\n\"2010/12/05 17:36:00\",\n\"2023/04/27 21:20:00\",\n\"2023/05/05 17:34:00\",\n\"2023/05/12 14:28:00\",\n\"2023/05/19 15:53:00\",\n\"2023/08/24 09:57:00\",\n\"2023/08/31 01:35:00\",\n\"2023/09/06 22:21:00\",\n\"2023/09/15 01:40:00\",\n\"2072/01/28 10:36:00\",\n\"2072/02/04 04:56:00\",\n\"2072/02/10 23:27:00\",\n\"2072/02/19 02:04:00\",\n\"2100/01/18 12:35:00\",\n\"2100/01/26 02:51:00\",\n\"2100/02/01 21:17:00\",\n\"2100/02/09 04:56:00\",\n\"1833/03/28 22:50:00\",\n\"1833/04/04 14:43:00\",\n\"1833/04/12 00:09:00\",\n\"1833/05/19 13:36:00\"),\n                        Phases = rep(c(\n\"First Quarter\", \"Full Moon\", \"Last Quarter\", \"New Moon\"),13)\n)\n#&gt; file_path &lt;- here::here(\"06\",\"moon\",\"USN_dates.txt\")\n#&gt; write.table(USN_dates, file = file_path, sep = \"\\t\", col.names = TRUE)\n\n\nHowever, the lunar phase estimates are not too far off from the observed dates. Let‚Äôs find out how accurate our function really is by calculating the mean prediction error for a bigger set of dates taken from the U.S Naval Observatory\n\n\n\nMean error of time difference (in mins) between predicted and actual dates\n\nYear\nFirst Quarter\nFull Moon\nLast Quarter\nNew Moon\n\n\n\n1701\n0.920\n0.930\n0.330\n0.200\n\n\n1833\n0.380\n0.560\n0.010\n0.290\n\n\n1930\n0.220\n0.310\n0.265\n0.610\n\n\n1971\n0.700\n0.550\n0.590\n0.275\n\n\n2010\n0.465\n1.150\n1.150\n0.955\n\n\n2023\n1.350\n1.565\n1.475\n1.305\n\n\n2072\n2.090\n1.640\n1.950\n1.720\n\n\n2100\n1.920\n1.830\n2.120\n2.070\n\n\n\n\n\nVisualizing it may provide a different perspective on the time discrepancy between the actual and the predicted dates of the lunar phases. We can see how the algorithm is more accurate as we reach the present and loses accuracy as we move away from it.\n\n\n\n\n\n\n\n\n\nFinally, we can accurately predict when the werewolves will turn üê∫, just kidding!\nIn all seriousness, the calc.MoonPhase function is accurate to within 2 minutes for a period of 400 years, but deteriorates as the time interval increases8. So, if an error of a few minutes is not important, we may use the algorithm to accurately predict the date of any lunar phase. However, we must also keep in mind that there will always be a small prediction error in every algorithm because the time interval between consecutive lunations will vary as the Sun perturbs the lunar path, and we cannot account for every force or action exerted on our ‚Äúlittle‚Äù satellite.\n\n\n\n\n8¬†the time difference in the expected date and the official date for the full moon of 0033/04/03 is 2 hrs, 50 mins and 24 seconds."
  },
  {
    "objectID": "blog/2024/04/dinosaurs/index.html",
    "href": "blog/2024/04/dinosaurs/index.html",
    "title": "Animating the Datasaurus dataset as part of the 30 Day Chart Challenge",
    "section": "",
    "text": "The 30DayChartChallenge is a data visualization community that hosts daily challenges for April. Today‚Äôs challenge involves dinosaurs. I used the Datasaurus package to create an animated visualization to demonstrate the importance of graphing data, and the effects of outliers on statistical properties. In these datasets, the mean and the standard deviation of \\(x\\) and \\(y\\) remain almost the same, but the distribution of observation pairs goes through obvious drastic changes."
  },
  {
    "objectID": "blog/2024/04/dinosaurs/index.html#visualization-pearsons-correlation-coefficient",
    "href": "blog/2024/04/dinosaurs/index.html#visualization-pearsons-correlation-coefficient",
    "title": "Animating the Datasaurus dataset as part of the 30 Day Chart Challenge",
    "section": "",
    "text": "The 30DayChartChallenge is a data visualization community that hosts daily challenges for April. Today‚Äôs challenge involves dinosaurs. I used the Datasaurus package to create an animated visualization to demonstrate the importance of graphing data, and the effects of outliers on statistical properties. In these datasets, the mean and the standard deviation of \\(x\\) and \\(y\\) remain almost the same, but the distribution of observation pairs goes through obvious drastic changes."
  },
  {
    "objectID": "blog/2024/04/dinosaurs/index.html#measures-of-central-tendency",
    "href": "blog/2024/04/dinosaurs/index.html#measures-of-central-tendency",
    "title": "Animating the Datasaurus dataset as part of the 30 Day Chart Challenge",
    "section": "Measures of Central Tendency",
    "text": "Measures of Central Tendency\n\nCodelibrary(datasauRus) \nlibrary(knitr)\nlibrary(tidyverse)\n\ndatasaurus &lt;- datasaurus_dozen\ngroup_datasaurus &lt;- datasaurus %&gt;%\n  summarize(avg = mean(x), \n            stdev = sd(x), \n            avg_y = mean(y), \n            stdev_y = sd(y))\n\nknitr::kable(group_datasaurus,\n             col.names = c('Mean(x)','SD(x)','Mean(y)','SD(y)'))\n\n\n\n\n\n\n\n\n\n\nMean(x)\nSD(x)\nMean(y)\nSD(y)\n\n\n54.2657\n16.713\n47.8351\n26.84777\n\n\nMean & Standard Deviation of x and y remain equal for each dataset\n\n\nCode## -------------------------------------- ##\n## Day 19: Dinosaurs; 30DayChartChallenge ##\n## -------------------------------------- ##\n## Loading libs                           ##\nlibrary(datasauRus)                       ##\nlibrary(tidyverse)                        ##\nlibrary(gganimate)                        ##                                                    \nlibrary(showtext)                         ##\n## -------------------------------------- ##\n\n# Setting custom theme for ggplot2 graphics\n\nclrs &lt;- c( # Creating custom color palette\n  \"#e5b858\", #  yellow\n  \"#B72025\", #  red\n  \"#7C225C\", #  purple\n  \"#d3d6d9\", #  dark gray\n  \"#f9f9f9\", #  light gray\n  \"#394DAA\") #  blue\n\n# Import Fonts (google name, R name)\nfont_add_google(\"Source Code Pro\",\"source_code\")\nfont_add_google(\"Montserrat\",\"mont\")\nshowtext_auto() # enable showtext font rendering\n\ntheme_blue &lt;- function() {\n  theme_minimal(base_family = \"mont\") +\n  theme(\n    plot.title = element_text(family = \"mont\", face = \"bold\", size = rel(1.35)),\n    plot.subtitle = element_text(family = \"mont\", colour = \"royalblue\", face = \"plain\", size = rel(1)),\n    plot.background = element_rect(fill = clrs[5], colour = clrs[5]),\n    panel.border = element_blank(),\n    panel.background = element_rect(fill = clrs[5]),\n    panel.grid.major.x = element_line(colour = clrs[6], linetype = 3, linewidth = .35),\n    panel.grid.minor.x = element_blank(),\n    panel.grid.major.y =  element_line(colour = clrs[6], linetype = 3, linewidth = .35),\n    panel.grid.minor.y = element_blank(),\n    # modify text, axis and colour 4) and 5)\n    axis.text = element_text(colour = clrs[6], face = \"plain\", family = \"mont\"),\n    axis.title = element_text(colour = clrs[6], family = \"mont\"),\n    axis.ticks = element_line(colour = clrs[6]),\n    # legend at the bottom 6)\n    legend.position = \"none\"\n  )\n}\n\ntheme_set(theme_blue())\n\nggplot2::update_geom_defaults(\"label\", list(family = \"mont\", fontface = \"bold\"))\nggplot2::update_geom_defaults(\"text\", list(family = \"mont\", fontface = \"plain\"))\n\n\n# Checking min/max for axis transform\ndatasaurus &lt;- datasaurus_dozen\nsummary(datasaurus)\n\ndino &lt;- ggplot(datasaurus, aes(x = x, y = y))+\n  geom_point(size = 3, alpha = .65, \n             colour = clrs[3]) +\n  labs(x = NULL,y = NULL,\n       title = \"Day 19 of 30 Day Chart Challenge\",\n       subtitle = \"The T-rex\",\n       caption = \"Always check your data graphically\") +\n  theme_blue() +\n  transition_states(states = dataset,\n                    transition_length = 2,\n                    state_length = 1,\n                    wrap = TRUE) +\n  ease_aes(\"linear\")\n\nanimate(dino, duration = 15, fps = 24, height = 680, width = 720,\n        renderer = gifski_renderer())\n\nanim_save(filename = \"dino.gif\",\n          path = here::here(\"blog\",\"2024\",\"04\",\"dinosaurs\",\"img\"))"
  },
  {
    "objectID": "blog/2024/04/dinosaurs/index.html#the-animated-data",
    "href": "blog/2024/04/dinosaurs/index.html#the-animated-data",
    "title": "Animating the Datasaurus dataset as part of the 30 Day Chart Challenge",
    "section": "The Animated Data",
    "text": "The Animated Data"
  },
  {
    "objectID": "cv/index.html",
    "href": "cv/index.html",
    "title": "R√©sum√©",
    "section": "",
    "text": "Download r√©sum√©"
  },
  {
    "objectID": "uses/index.html",
    "href": "uses/index.html",
    "title": "What I use",
    "section": "",
    "text": "I‚Äôve gradually discovered a research workflow that suits my needs (and my budgetüòÖ) and maximizes productivity.\nI‚Äôm leaving a list of the programs/software I regularly use as a way to track the changes to my workflow and also provide guidance to those looking for free resources to increase their efficiency and organization."
  },
  {
    "objectID": "uses/index.html#discovery-and-idea-generation",
    "href": "uses/index.html#discovery-and-idea-generation",
    "title": "What I use",
    "section": "Discovery and Idea Generation",
    "text": "Discovery and Idea Generation\nWriting\n\nI use Joplin‚Äì an open-source note-taking app with a markdown editor and customizable plugins. Another great option is Obsidian which includes knowledge graphs to organize your thoughts.\nI use Typora to create stand-alone markdown files. Typora also supports pandoc-flavored markdown which makes it easier to transform markdown to other formats like .docx, .pdf, etc.\nI use a good ol‚Äô Mead Five Star Spiral Fat Lil‚Äô Pocket Notebook for note-taking (books I read, ideas, summaries, schedules, to-do lists). I‚Äôve tried planners, calendars, apps and none of those things seem to keep me on track as brilliantly as a handwritten note in one of those fat little notebooks.\nI use Mendeley as my bibliography and citation manager. The free plan includes 2GB of storage, which is more than I need. I store my bibliographies in Bibtex format.\nI use Overleaf and Detexify which makes finding LateX symbols a breeze. Just draw the symbol you‚Äôre looking for and the site provides a list of possible matches with their LateX syntax.\nI use Natural Speech Reader to help with text editing."
  },
  {
    "objectID": "uses/index.html#data-collection-and-analysis",
    "href": "uses/index.html#data-collection-and-analysis",
    "title": "What I use",
    "section": "Data Collection and Analysis",
    "text": "Data Collection and Analysis\nScience and Research\n\nI currently use R and RStudio for my data analysis and graphing needs, and VSCode for everything else.\nI used G-Power and piface for sample size calculations, but their utility decreased as I began to use more complicated models.\nMy main statistical programming software was SPSS until 2020, but its lackluster versatility left me disappointed. I especially didn‚Äôt like all the clicking and the way their syntax, output, and data panels were set up. Unfortunately, that‚Äôs the software of choice in many universities in the U.S., including mine.\nI also use Notepad ++, a text editor that supports more than two dozen programming languages (not markdown). I sometimes use it alongside VSCode.\nI use Github and Git Bash to store almost everything I write and for version control."
  },
  {
    "objectID": "uses/index.html#publication",
    "href": "uses/index.html#publication",
    "title": "What I use",
    "section": "Publication",
    "text": "Publication\nGraphic Design\n\nI‚Äôve used Canva for every design in this website and personal documents. I also have free access to Adobe InDesign but haven‚Äôt used it much.\nI totally recommend Practical Typography, by Matthew Butterick‚Äì a typograhpy primer for the graphic designer and the layperson trying to create beautiful documents.\nI have been learning Pollen, a markup language used to create beautiful digital books.\nI use PowerPoint to create simple and stunning presentations. I have free access to Microsoft products, and it‚Äôs also the best slide editor I‚Äôve seen.\nI use Google Fonts API for font selection and David Jonathan Ross‚Äô typefaces. My preferred fonts are Arsenal, ETBembo, EB Garamond, Warbler, Livory, Charter, and Cooper Hewitt.\nProductivity\n\nI use Dropbox and Google One for file storage and backup. I get Dropbox for free through my school, and I pay for a family Google One subscription. However, both services cost about the same and offer similar storage space (3TB and 2TB respectively).\nI use the Windows Clock app focus feature to track my time. I‚Äôm not easily distracted if I‚Äôm working towards a concrete, timed goal so scheduling times of intense mental activity is a huge help.\nI use Otter.ai as my audio recording and automatic transcription service. I record presentations, interviews, talks, etc. and Otter.ai produces a solid transcript that I can then save or use in content creation.\nI use Chat GPT to answer all sorts of questions and to guide me in the creative process."
  },
  {
    "objectID": "uses/index.html#hardware",
    "href": "uses/index.html#hardware",
    "title": "What I use",
    "section": "Hardware",
    "text": "Hardware\n\nI use Yubico and Keybase for privacy and security.\nI use a 2020 15.6‚Ä≥ i5Core Dell, a 2020 13‚Ä≥ MacBook Pro, and an iPhone 13 mini."
  },
  {
    "objectID": "uses/index.html#guides",
    "href": "uses/index.html#guides",
    "title": "What I use",
    "section": "Guides",
    "text": "Guides\n\n\nGood enough practices in scientific computing detail the process of organizing, structuring, and sharing data and research with collaborators while keeping track of all the changes.\n\nFour steps to an applied micro paper, by Jesse Shapiro, outlines the process of writing an academic paper in the applied sciences. It‚Äôs a very succinct guide to help students and researchers improve their writing.\n\nHow to give an applied micro talk, also by Jesse Shapiro, is a brief explanation of why your presentations should be short and engaging, not so tediously structured and technical.\n\nPublic speaking for academic economists, by Rachel Meager, provides a simple and witty guide to public speaking for researchers and academics.\n\nThe Plain Person‚Äôs Guide to Plain Text Social Science. A useful primer on organizing and structuring your writing and research process in the Social Science sphere. It provides a template for research and writing that you can transform to suit your needs and budget (I mostly use free software except for Typora and Google One).\nKieran Healy‚Äôs Making Slides guide to creating engaging slides by using layers, highlighting, and repetition to build your argument."
  },
  {
    "objectID": "blog/index.html#section",
    "href": "blog/index.html#section",
    "title": "Blog",
    "section": "2024",
    "text": "2024\n\n\n    \n    \n                  \n            Jul 3, 2024\n        \n        \n            the iterated prisoners' dilemma\n\n            \n\n            rudimentary solutions using R\n            \n            \n            10.59350/gyxmw-enh88\n            \n        \n        \n    \n    \n    \n                  \n            Jun 27, 2024\n        \n        \n            swear not by the moon, the fickle moon\n\n            \n\n             a complex prediction algorithm in r\n            \n            \n            10.59350/b0na5-5km65\n            \n        \n        \n    \n    \n    \n                  \n            Apr 19, 2024\n        \n        \n            animated datasaurus‚Äî30 day chart challenge\n\n            \n\n            dinosaurs & correlation coefficients\n            \n            \n            10.59350/wx5k1-ajc38\n            \n        \n        \n    \n    \n    \n                  \n            Apr 15, 2024\n        \n        \n            beautiful movement‚Äîlissajous curves\n\n            \n\n            exploration of lissajous curves \n            \n            \n            10.59350/y9kmp-zqh66\n            \n        \n        \n    \n    \n    \n                  \n            Mar 17, 2024\n        \n        \n            don't be an absolutist. Use the here package\n\n            \n\n            the `here` package for your `RStudio` projects\n            \n            \n            10.59350/4a9fr-acc34\n            \n        \n        \n    \n    \n\n\nNo matching items"
  },
  {
    "objectID": "research/articles/index.html",
    "href": "research/articles/index.html",
    "title": "On the Surgical Removal of Cardassian Cranial Implants: A case study of a Cardassian patient",
    "section": "",
    "text": "Paper (preprint)\nStatistical analysis notebook\nGitHub repository"
  },
  {
    "objectID": "research/articles/index.html#important-links",
    "href": "research/articles/index.html#important-links",
    "title": "On the Surgical Removal of Cardassian Cranial Implants: A case study of a Cardassian patient",
    "section": "",
    "text": "Paper (preprint)\nStatistical analysis notebook\nGitHub repository"
  },
  {
    "objectID": "research/articles/index.html#abstract",
    "href": "research/articles/index.html#abstract",
    "title": "On the Surgical Removal of Cardassian Cranial Implants: A case study of a Cardassian patient",
    "section": "Abstract",
    "text": "Abstract\nI have reset the sensors to scan for frequencies outside the usual range. By emitting harmonic vibrations to shatter the lattices. We will monitor and adjust the frequency of the resonators. He has this ability of instantly interpreting and extrapolating any verbal communication he hears. It may be due to the envelope over the structure, causing hydrogen-carbon helix patterns throughout. I‚Äôm comparing the molecular integrity of that bubble against our phasers."
  },
  {
    "objectID": "research/articles/index.html#important-notes",
    "href": "research/articles/index.html#important-notes",
    "title": "On the Surgical Removal of Cardassian Cranial Implants: A case study of a Cardassian patient",
    "section": "Important notes",
    "text": "Important notes\nStellar flares are increasing in magnitude and frequency. Set course for Rhomboid Dronegar 006, warp seven. There‚Äôs no evidence of an advanced communication network. Total guidance system failure, with less than 24 hours‚Äô reserve power. Shield effectiveness has been reduced 12 percent. We have covered the area in a spherical pattern which a ship without warp drive could cross in the given time.\nResistance is futile."
  },
  {
    "objectID": "research/articles/index.html#citation",
    "href": "research/articles/index.html#citation",
    "title": "On the Surgical Removal of Cardassian Cranial Implants: A case study of a Cardassian patient",
    "section": "Citation",
    "text": "Citation\n\n‚ÄÉAdd to Mendeley \n\n@article{BashirGarak:2178,\n    Author = {Julian Bashier and Elim Garak},\n    Journal = {Starbase Deep Space Nine},\n    Month = {9},\n    Number = {9},\n    Pages = {1425--1439},\n    Title = {On the Surgical Removal of Cardassian Cranial Implants: A case study of a Cardassian patient},\n    Volume = {130},\n    Year = {2178}}"
  },
  {
    "objectID": "about/index.html",
    "href": "about/index.html",
    "title": "JP Monteagudo",
    "section": "",
    "text": "hello there,\n\nThanks for stopping by!\nI‚Äôm an aspiring epidemiologist currently pursuing post-graduate studies in Epidemiology at Liberty University. I‚Äôm interested in clinical epidemiology, epidemiological research methods, infectious diseases, pharmaco-epidemiology, geographical information system (GIS) and demography.\nI love statistics and the R programming language. I‚Äôm currently taking a deep dive into generalized linear models, Bayesian inference and package development.\nNowadays, I work as a Learning & Development Specialist conducting a pilot study analyzing the impact of new hire training on performance in a fast-paced contact center environment."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "jp monteagudo",
    "section": "",
    "text": "Hi, my name is JP.\n\n\nI‚Äôm passionate about human health, statistics, code, data and design. This website is a collection of projects, research, and discussions on topics that I find interesting and meaningful. My goal is to make this site a source of publicly available data, code and insights that can be used by others to advance their learning journey.\n\nLearn more about me ‚Üí"
  },
  {
    "objectID": "research/index.html",
    "href": "research/index.html",
    "title": "Research",
    "section": "",
    "text": "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."
  },
  {
    "objectID": "research/index.html#journal-articles",
    "href": "research/index.html#journal-articles",
    "title": "Research",
    "section": "Journal articles",
    "text": "Journal articles\n\n\n\n    \n        \n            \n                Julian Bashir and Elim Garak, ‚ÄúOn the Surgical Removal of Cardassian Cranial Implants: A case study of a Cardassian patient‚Äù Starbase Deep Nine Archives 130, no. 9 (September 2178): 1425‚Äì1439\n            \n\n            \n\n            \n            \n            \n            \n                These brain distortions‚Äì\n            \n                 / horse loose in a hospital.\n            \n                 / Surgery?...Proceed.\n            \n            \n            \n            \n            \n                \n                    \n                        \n                             Full details ¬ª\n                        \n                    \n                    \n                        \n                    \n                        \n                        \n                        \n                             Preprint\n                        \n                    \n                        \n                    \n                        \n                        \n                        \n                             Final version\n                        \n                    \n                        \n                    \n                        \n                        \n                        \n                             Code\n                        \n                    \n                        \n                    \n                        \n                        \n                        \n                             Add to Mendeley\n                        \n                    \n                        \n                    \n                \n            \n        \n        \n\n\n\nNo matching items"
  },
  {
    "objectID": "now/index.html",
    "href": "now/index.html",
    "title": "Nowadays",
    "section": "",
    "text": "This year has a busy one for me:\n\nI‚Äôm doing my MSPH in Epidemiology and figuring out what research opportunities are available at my university.\nAfter the COVID-19 pandemic, I‚Äôve been working from home and spent a lot of time with my family.\nI‚Äôm working full-time as a Learning and Development Specialist\nI‚Äôve been reading up on some R programming books and have been able to get one package, despair,submitted and approved on CRAN. I‚Äôm currently working on two other packages, describe and deals with descriptive and missing data, and guides which allows the user to move their directory to any folder or file inside or outside an R project.\nI‚Äôm currently reading An Introduction to Generalized Linear Models, Epidemiology by Design, and Flexible Imputation of Missing Data by Stef van Buuren\nI have been obsessed with kettlebells for the past three years. I‚Äôve mastered a few movements but there‚Äôs still a lot of ground to cover.\nEversince we moved to our new house, I‚Äôve been working on some house repairs.\nI‚Äôve been reading science and religion books for the past three years until recently, when I decided to reread the classics and tell them to my girls who aren‚Äôt old enough to read those yet."
  },
  {
    "objectID": "blog/2024/04/lissajous/index.html",
    "href": "blog/2024/04/lissajous/index.html",
    "title": "beautiful movement‚Äîlissajous curves",
    "section": "",
    "text": "Lissajous curves are created by plotting two oscillations on perpendicular axes \\(x\\) and \\(y\\)‚Äã‚Äã‚Äã. These oscillations, represented by sinusoidal functions, intersect to create different patterns. When the ratio of these frequencies is equal to \\(1\\)‚Äî the oscillations are equally phased‚Äî the curve is a straight line. When the frequencies on both axes differ, the oscillations are out of phase‚Äîone moves faster than the other at a specific angle‚Äîand our Lissajous figure will show a curve. Each frequency produces a specific musical note that will intercept and either form a pleasant sound, harmonious consonance or discordance. Consonant notes have a perfect ratio."
  },
  {
    "objectID": "blog/2024/04/lissajous/index.html#lissajous-curves",
    "href": "blog/2024/04/lissajous/index.html#lissajous-curves",
    "title": "beautiful movement‚Äîlissajous curves",
    "section": "",
    "text": "Lissajous curves are created by plotting two oscillations on perpendicular axes \\(x\\) and \\(y\\)‚Äã‚Äã‚Äã. These oscillations, represented by sinusoidal functions, intersect to create different patterns. When the ratio of these frequencies is equal to \\(1\\)‚Äî the oscillations are equally phased‚Äî the curve is a straight line. When the frequencies on both axes differ, the oscillations are out of phase‚Äîone moves faster than the other at a specific angle‚Äîand our Lissajous figure will show a curve. Each frequency produces a specific musical note that will intercept and either form a pleasant sound, harmonious consonance or discordance. Consonant notes have a perfect ratio."
  },
  {
    "objectID": "blog/2024/04/lissajous/index.html#music-perfect-ratios",
    "href": "blog/2024/04/lissajous/index.html#music-perfect-ratios",
    "title": "beautiful movement‚Äîlissajous curves",
    "section": "Music & Perfect Ratios",
    "text": "Music & Perfect Ratios\nThink of a guitar string vibrating at a base frequency of \\(329 Hz\\)‚Äî\\(329\\) cycles per second. By altering our position along the string, we change the frequency and thus produce different notes. If we moved from the nut (fret \\(0\\)) to between frets \\(11\\) and \\(12\\) and plucked the string, the frequency would now be twice as high‚Äîwe call this an octave. If we moved \\(3/4\\) down from the nut, our new note would oscillate at three times the frequency of E4(\\(329Hz\\)). We can produce an infinite amount of notes by moving along the string and altering the speed of the oscillations. You are creating music with movement!\nTheory of Just Intonation\nHowever, keeping track of an infinite, unordered sequence of notes is impossible; instead, we use systems that allow us to measure and obtain the frequency of a small number of notes. One such system is called ‚Äújust intonation‚Äù and a commonly seen tuning method is 5-limit tuning. This method allows us to find the exact, pure frequency of other notes by multiplying our base frequency by products of the power of prime numbers \\(2\\), \\(3\\), and \\(5\\) (e.g., \\(2^{-1} \\cdot 3^{1} \\cdot 5^{1}\\)).1\n1¬†In 5‚Äìlimit tuning we only multiply integers to obtain other musical notes.2¬†octaves: \\(f_{x} = 2^{k}\\); perfect fifths: \\(3^{k}\\), major thirds: \\(5^{k},k \\in \\mathbb{Z}\\).3¬†Sometimes the resulting note is outside our octave, and we simply divide it by two and bring it back to our interval.¬†¬†¬†¬†¬†¬†We call the sinusoidal movements in intervals of powers of \\(2\\) ‚Äì octaves, powers of \\(3\\) represent perfect fifths, and powers of \\(5\\) are called major thirds2. By multiplying our base frequency by different combinations of these powers,3 we get sets of harmoniously consonant and discordant notes.\nThe Perfect ratios\nSo how can we make sure every note is consonant? Thankfully, the ancient Greeks discovered a way to create beautifully sounding and naturally occurring notes using perfect4 ratios for octaves, major fifths, and major thirds. These perfect ratios make music blend, flow, and feel ‚Äúright‚Äù. These are the ratios that create all of the Lissajous figures we‚Äôll explore today.\n4¬†perfect refers to ratios that produce ‚Äújust‚Äù or ‚Äúpure‚Äù melodic sounds.\nCoderatios &lt;- c(1,\"9/8\", \"5/4\",\"4/3\",\"3/2\", \"5/3\",\"15/8\",2,240,270,300,320,360,400,450,480)\ncols &lt;- c(\"C\",\"D\",\"E\",\"F\",\"G\",\"A\",\"B\",\"C'\")\nrows &lt;- c(\"Perfect Ratios\", \"Frequency(in Hz)\")\nperfect_ratios &lt;- matrix(ratios, ncol = 8, byrow = TRUE)\ncolnames(perfect_ratios) &lt;- cols\nrownames(perfect_ratios) &lt;- rows\nperfect_ratios\n##                  C     D     E     F     G     A     B      C'   \n## Perfect Ratios   \"1\"   \"9/8\" \"5/4\" \"4/3\" \"3/2\" \"5/3\" \"15/8\" \"2\"  \n## Frequency(in Hz) \"240\" \"270\" \"300\" \"320\" \"360\" \"400\" \"450\"  \"480\"\nknitr::kable(perfect_ratios)\n\n\nPerfect ratios in Just Intonation using 5-limit tuning method\n\n\n\n\n\n\n\n\n\n\n\n\n\nC\nD\nE\nF\nG\nA\nB\nC‚Äô\n\n\n\nPerfect Ratios\n1\n9/8\n5/4\n4/3\n3/2\n5/3\n15/8\n2\n\n\nFrequency(in Hz)\n240\n270\n300\n320\n360\n400\n450\n480"
  },
  {
    "objectID": "blog/2024/04/lissajous/index.html#the-code-animation",
    "href": "blog/2024/04/lissajous/index.html#the-code-animation",
    "title": "beautiful movement‚Äîlissajous curves",
    "section": "The Code & Animation",
    "text": "The Code & Animation\nWe‚Äôll create the Lissajous curves using two sinusoidal waves on different phases 5. The numerator of the perfect ratio will be the coefficient \\(a\\) of the \\(sin\\) function, \\(sin(t) = sin(at + \\delta)\\), and the denominator \\(b\\) will go to the \\(y\\) coordinate \\(sin(t) = sin(bt)\\). We‚Äôll define our interval from \\(0\\) to \\(2\\pi\\).‚Äã‚Äã\n5¬†the curves can also be created with \\(sin(t)\\) and \\(cos(t)\\) functions since \\(cos(t) = sin(t + \\frac{\\pi}{2})\\), but the phase difference will now be \\(\\frac{a}{b}*\\frac{\\pi}{2}\\).\n\n\n\n\n\nHelpful Tip\n\n\n\nYou can familiarize yourself with Lissajous figures and their sine functions by using this interactive virtual oscilloscope.\n\n\n¬†¬†¬†¬†Using the gganimate package in RStudio, we‚Äôll build a data frame with a set number of times steps between \\(0\\) and \\(2\\pi\\)‚Äã; and the figures with coordinates for each perfect ratio. Then, we‚Äôll stitch each plot with the time steps and coordinates to get a final \\(8 √ó 8\\) animated plot.\n\nCode## ------------------------------- ##\n## Creating Lissajous figures      ##\n## ------------------------------- ##\nlibrary(gganimate)# Loading libs   ##\nlibrary(tidyverse)                 ##\nlibrary(here)                      ##\nlibrary(av)                        ##\n## ------------------------------- ##\n\nparams &lt;- data.frame(\n  id &lt;- seq(1,500,1), # no. of steps\n  t &lt;- seq(0,2*pi, length.out = 500)  # equally spaced intervals 0-2*pi\n)\n\nfigs &lt;- function(t){\n  x1 &lt;- sin(t*1) # We're only using perfect ratios\n  y1 &lt;- sin(t*1)\n  \n  x2 &lt;- sin(t*9)\n  y2 &lt;- sin(t*8)\n  \n  x3 &lt;- sin(t*5)\n  y3 &lt;- sin(t*4)\n  \n  x4 &lt;- sin(t*4)\n  y4 &lt;- sin(t*3)\n  \n  x5 &lt;- sin(t*3)\n  y5 &lt;- sin(t*2)\n  \n  x6 &lt;- sin(t*5)\n  y6 &lt;- sin(t*3)\n  \n  x7 &lt;- sin(t*15)\n  y7 &lt;-  sin(t*8)\n  \n  x8 &lt;- sin(t*2)\n  y8 &lt;- sin(t*1)\n  \n  time &lt;- seq_along(t)\n  \n  data.frame( # Create df with x, y variables accross time\n    time, \n    x1, x2, x3, x4, x5, x6, x7, x8,\n    y1, y2, y3, y4, y5, y6, y7, y8\n  )\n}\n\nactual_figs &lt;- figs(params$t)\n\ndf &lt;- bind_cols(params, actual_figs) |&gt; # bind two dfs\n  select(everything()) |&gt; # make data long\n  pivot_longer(x1:x8, names_to = \"x_group\", values_to = \"x\") |&gt;\n  pivot_longer(y1:y8, names_to = \"y_group\", values_to = \"y\") |&gt;\n  mutate(x_group = str_remove(x_group, \"x\"),\n         y_group = str_remove(y_group, \"y\")) |&gt;\n  unite(\"group_id\", x_group, y_group, remove = FALSE)\n\nplot &lt;- df|&gt;\n  ggplot(aes(x = x, y = y, color = group_id, group = group_id)) +\n  geom_point(size = 3) +\n  geom_path() +\n  facet_grid(x_group ~ y_group) +\n  coord_equal() +\n  guides(color = \"none\") +\n  theme_void() +\n  transition_reveal(time) +\n  ease_aes(\"linear\")\n\nanimate(plot, duration = 30, fps = 24, height = 1080, width = 1080,\n        renderer = av_renderer())\n\nanim_save(filename = \"lissajous_figs.mp4\",\n          path = here::here(\"blog\",\"2024\",\"04\",\"lissajous\",\"documents\"),\n          height = 1080, width = 1080)\n#| Code adapted from Kieran Healy's blog \"Pi Day Circles\""
  },
  {
    "objectID": "blog/2024/04/lissajous/index.html#the-final-product",
    "href": "blog/2024/04/lissajous/index.html#the-final-product",
    "title": "beautiful movement‚Äîlissajous curves",
    "section": "The Final Product",
    "text": "The Final Product\nHere‚Äôs the final, animated \\(8√ó8\\) plot displaying Lissajous figures using only the perfect ratios."
  },
  {
    "objectID": "blog/2024/03/here/index.html",
    "href": "blog/2024/03/here/index.html",
    "title": "Don‚Äôt be an absolutist. Use the here package for reproducible workflows",
    "section": "",
    "text": "Don‚Äôt be an absolutist‚Äì use relative paths. Use the here package instead of setwd() or getwd() to increase reproducibility and avoid wasting your and other people‚Äôs time."
  },
  {
    "objectID": "blog/2024/03/here/index.html#tldr",
    "href": "blog/2024/03/here/index.html#tldr",
    "title": "Don‚Äôt be an absolutist. Use the here package for reproducible workflows",
    "section": "",
    "text": "Don‚Äôt be an absolutist‚Äì use relative paths. Use the here package instead of setwd() or getwd() to increase reproducibility and avoid wasting your and other people‚Äôs time."
  },
  {
    "objectID": "blog/2024/03/here/index.html#whats-the-problem-with-setwd",
    "href": "blog/2024/03/here/index.html#whats-the-problem-with-setwd",
    "title": "Don‚Äôt be an absolutist. Use the here package for reproducible workflows",
    "section": "What‚Äôs the problem with setwd()?",
    "text": "What‚Äôs the problem with setwd()?\nSince I created this website, I‚Äôve been coding, writing, and reading a lot more which has unequivocally led to a mountain of new files and the forging of new paths‚Äì quite literally. At first, I kept things pretty organized, but now it‚Äôs nearly impossible to know where I saved such_and_such.txt file without wasting at least 5 minutes of my day.\nThis is what I used to do:\n\nurl1 &lt;- \"https://somefile_online_data_source_here.com\"\ndownload.file(url1, destfile = \"./data_file_here.zip\")\nunzip(\"data_file_here.zip\", exdir = getwd())\nDat &lt;- readRDS(\"summaryDat.rds\")\nDat2 &lt;- readRDS(\"SummaryDat2.rds\")\n\nMy directory will be anywhere on my device unless I have previously specified it using setwd(), but this strategy will soon be an obstacle to saving new information in an organized and reproducible way. If, later on, I change my R scripts to a different folder the original file path won‚Äôt work anymore."
  },
  {
    "objectID": "blog/2024/03/here/index.html#here-is-the-solution",
    "href": "blog/2024/03/here/index.html#here-is-the-solution",
    "title": "Don‚Äôt be an absolutist. Use the here package for reproducible workflows",
    "section": "\nhere is the solution üìÅ",
    "text": "here is the solution üìÅ\nThe here package allows you to set up a relative path mapped onto your R project directory on every device regardless of your absolute path.\nThe here function\nSuppose my directory is located in the Project folder. The here package is going to look for the .Rproj file and establish the root directory there.\n\n# Project/\n#    |\n#    |__ data/\n#    |    |___  summaryDat.rds\n#    |    |___  summaryDat2.rds\n#    |\n#    |__ blog/\n#    |    |_____index.qmd\n#    |    |\n#    |    |__ post/\n#    |    | |______ 2024/\n#    |    |       |____ 02/\n#    |    |          |____  index.qmd\n#    |    |              |____  dat3.R\n#    |    |__ img/\n#    |      |_____  plots.png\n#    |\n#    |__ scripts/\n#      |____ ind.R\n#      |____ cond.R\n\nHere you can see my root directory and how that changes with each iteration of the here command.\n\nlibrary(here)\nhere::here()\n# [1] \"C:/Users/jpmonteagudo/Desktop/R/Project\"\n  here::here(\"blog\")\n# [1] \"C:/Users/jpmonteagudo/Desktop/R/Project/blog\"\n  here::here(\"scripts\")\n# [1] \"C:/Users/jpmonteagudo/Desktop/R/Project/scripts\"\n# I'll point R to the actual document by providing the full relative path\nhere::here(\"blog\",\"post\",\"2024\",\"02\",\"dat3.R\")\n# [1] \"C:/Users/jpmonteagudo/Desktop/R/Project/blog/post/2024/02/dat3.R\"\n\nI can also go up several folders at once by using the full relative path. However, when I call the here function again, it sends me back to my root directory.\n\nhere::here()\n# [1] \"C:/Users/jpmonteagudo/Desktop/R/Project\"\n\nI would use the here function to get or write files and not just be there. If I don‚Äôt need anything from my subdirectory, then R will go back to its root, the .Rproj. For example, saving a .png file with multiple plots involves specifying the relative path using here::here().\n\n\n## Using ggplot2 to save my plots\n\nggsave(\"plots.png\",arranged_plots, \n       path = here::here(\"blog\",\"2024\",\"02\",\"post\",\"img\"),\n                width = 800,\n                height = 600,\n                units = \"px\",\n                dpi = 72)\n\n## The same can be done using base R\n\ndev.copy(png,here::here(\"blog\",\"2024\",\"02\",\"clt\",\"img\",\"plots.png\"), width = 800, height = 600)\ndev.off()\n\nThe set_here function\nIf I want to ‚Äújust be somewhere‚Äù anytime I open my project, I would use another function‚Äì the set_here function. Basically, this function creates a .here file anywhere in your project so you can use this directory as your root. Here‚Äôs the description in the function‚Äôs syntax\n\nWhen here encounters such a file, it uses the directory that contains this file as root. This is useful if none of the default criteria apply. You need to restart the R session so that here() picks up the newly created file.\n\n\nhere::set_here(\"blog/2024\")\n# Created file .here in C:\\Users\\jpmonteagudo\\Desktop\\R\\Project\\blog\\2024. \n# Please start a new R session in the new project directory.\n\nNext, I start a new R session here, and RStudio will automatically set my directory to this folder. I don‚Äôt need to open the R project to reach this new directory. It will give me access to the folder‚Äôs files, and I can then set a relative path to other files.\n\n# Checking directory in new R session\nhere::here()\n# [1] \"C:/Users/jpmonteagudo/Desktop/R/Project/blog/2024\"\n\nFrom this new directory, I can reach files anywhere by using the here::here() function.\nThe confusing i_am function\nThis function has given me a headache. The here package is supposed to be a tool that facilitates collaboration and connectivity, but I just couldn‚Äôt get it to work until now.\nCall the here::i_am() function at the top of your script in the first chunk of your markdown file. It will accept a relative path and then establish the new project root there. So far, it only works when I point R to a specific file I‚Äôd like to work with. If I choose a file path that‚Äôs not in my project directory, it will just point to the original directory and throw an error. If the current directory is outside of the project where the current script is running, you‚Äôll get an error message: Could not find associated project in working directory or any parent directory.\n\n# You're in the scripts folder working on ind.R but need to access summaryDat2.rds.\n#  Simply include the relative path to the data file at the top of your script:\nlibrary(readr)\ndata &lt;- read_csv(here::i_am(\"data/summaryDat2.rds\"))\n# From my script I'm now pointing to a folder containing my Dat2.R\n\nThe dr_here function\nThe here::dr_here() shows a default message explaining why the current directory was chosen. You probably won‚Äôt use this function often‚Äì unless you‚Äôre curious and want to understand how the package selects the root directory. However, if you used here::here(\"file_path\") and got an unexpected result, go ahead and call here::dr_here. It‚Äôll most likely ask you to create a .here file or set your directory using the here::i_am() function.\nIn the end, the here package will make it easy to collaborate and work on your projects on any device by using the here::i_am(), here::here(), and here::set_here() functions."
  },
  {
    "objectID": "blog/2024/05/prisoners/index.html",
    "href": "blog/2024/05/prisoners/index.html",
    "title": "the iterated prisoners‚Äô dilemma",
    "section": "",
    "text": "Recently, I become intrigued by game theory algorithms, not because I absolutely love playing games, but because it offers a quantifiable, systematic way to understand human relationships. I find the certainty of science and systematization reassuring to some degree so when I learned about this game called ‚Äúthe prisoner‚Äô dilemma‚Äù, I thought it would fun to experiment and figure out the answer to this classic scenario. This game‚Äôs solution extends beyond hypothetical situations, addressing questions like: What‚Äôs the best strategy for handling conflict in various contexts‚Äîbe it a card game, a business deal, or interpersonal relationships? Should we always cooperate and risk betrayal?\nIn his landmark work, R. Axelrod1 said:\n1¬†The Evolution of Cooperation. Basic Books, Inc. New York, 1984\nThe Cooperation theory [here] is based upon an investigation of individuals who pursue their own self‚Äìinterest wihtout the aid of central authority to force them to cooperate with each other. The reason for assuming self‚Äìinterest is that it allows an examination of the difficult case when cooperation is not completely based upon a concern for others or upon the welfare of the groups as a whole.\n\nI‚Äôve heard the phrases ‚ÄúMeet in the middle‚Äù, ‚Äúalways compromise‚Äù or ‚Äúnever split the difference‚Äù but they all seem either idealistic or downright selfish. In a high-stakes situation, should we always cooperate? Yes or not so quickly!?.\n\nLet the prisoner‚Äôs dilemma answer these questions for us.\nThe iterated version of the dilemma was presented as a hypothetical scenario by R. Axelrod:\nTwo bank robbers happen to meet. They decide to pull a job together. The cops nab them, but without enough evidence to convict. They need a confession. And they know both robbers are unlikely to talk, since if neither implicates the other, the cops can keep them in jail for only 30 days.\nSo they put the two in separate cells. They go to the first prisoner and say: ‚ÄúIf you rat on your partner and he stays mum, we‚Äôll let you go and he‚Äôll do ten years.If you both rat on each other, you‚Äôll both do eight years.‚Äù Then they go to the second prisoner and say the same thing.\nThe first prisoner thinks it over. ‚ÄúIf he rats on me and I don‚Äôt rat on him, then I lose big-time. If I rat on him and he doesn‚Äôt rat on me, then I win big-time. Either way, the smart move is to rat on him. I‚Äôll just hope he‚Äôs a sucker and doesn‚Äôt rat on me.‚Äù The second prisoner reasons the same way. So they rat on each other, and the cops get their two convictions. If the prisoners had cooperated, both would have gotten off easy. Instead, the rational pursuit of self-interest has put them both in a world of pain.\nTo win the game, at least one player must cooperate in the face of betrayal, otherwise both contestants would face unfavorable outcomes.\n\nThe rules of the iterated prisoner‚Äôs dilemma:\n\nTwo players play 200 matches against each other and against an algorithm that betrayed or cooperated at random.\nPlayers obtain three points for mutual cooperation, one for a mutual betrayal, and five for the player who betrays when the other cooperates.\n\n\nI‚Äôll attempt to provide four solutions to this problem. The first algorithm will never be the first to betray and will copy the opponent‚Äôs previous choice. The second solution will betray in response to a cooperation five percent of the time; the third solution will not cooperate first and then imitate each of player 1‚Äôs choices, and the last one will never betray first, but will retaliate in turn on every remaining move until the end of the game.\nThe official winning strategy was the following:\n\nIn the first match-up, cooperate.\nIn every match-up after that, do what the opponent did in the preceding match-up.\n\nI‚Äôll imitate this strategy in the first algorithm.\nFirst,I‚Äôll create a function for player 2 that chooses to cooperate on the first attempt, and copies player 1‚Äôs previous choice on subsequent moves. To do this, I have to iterate over each of player 1‚Äôs choices, and store player 2‚Äôs replies in a new vector.\nTo determine the choice order I‚Äôll create a vector of length 2 with player 1‚Äôs original choice and subtract 1 from that choice to obtain the alternative. To create the vector of choices of length \\(n\\), I‚Äôll append player 1‚Äôs original choice to a vector of length \\(n-1\\) ensuring that the first choice is always in position 1 p1[1]. The resulting vector will be of length n.\nWe‚Äôll make a vector or player 2‚Äôs choices of length \\(n\\) equal to p1. The first choice will always be cooperation, and all subsequent choices will be player 1‚Äôs previous response p1[ i -1].\n\n\n\n\n\n\nAlways remember to initialize vectors and perform operations outside the loop, if possible. Doing this will sometimes make your function much, much faster.\n\n\n\n\n#&gt; @rounds: number of rounds or matches in one game\n#&gt; @prob: probability of betrayal and cooperation\n#&gt; @choice: first choice to start the game. Choice inversion will be applied if staring choice = 1\n#&gt; @replace: sampling with replacement based on choice order. A vector of length 2\n\ntit.for.tat &lt;- function(rounds, \n                        prob, \n                        choice,\n                        replace = TRUE,\n                        ...){\n  \n  # Check arguments\n  stopifnot({\n    is.integer(rounds)\n    is.double(prob)\n    is.logical(choice)\n    is.logical(replace)\n  })\n  \n  choice_order &lt;- c(choice, 1 - choice)\n  p1 &lt;- logical(rounds)\n  p2 &lt;- logical(rounds)\n  \n  \n  p1[1] &lt;- choice\n  p2[1] &lt;- TRUE  \n  \n  for (i in 2:rounds) {\n    if (choice_order[1] == TRUE) {\n      inv.prob &lt;- c(prob[2], prob[1])\n      p1[i] &lt;- sample(choice_order, size = 1, replace = replace, prob = inv.prob)\n    } else {\n      p1[i] &lt;- sample(choice_order, size = 1, replace = replace, prob = prob)\n    }\n    \n    p2[i] &lt;- p1[i - 1]\n  }\n  result &lt;- list(P1 = as.numeric(p1), \n                 P2 = as.numeric(p2))\n  return(result)\n}\n\ntable(tit.for.tat(200,prob = c(.459,.237), choice = 0, replace = T))\n#&gt;    P2\n#&gt; P1   0  1\n#&gt;   0 85 47\n#&gt;   1 47 21\n\n\nThe only difference between Tit‚Äìfor‚ÄìTat and the BSP2 is that we‚Äôre adding a random component that will cause player 2 to betray player 1 after a cooperation. Player 2 will always cooperate on the first round, but the algorithm will be less predictable than the previous one. I may be wrong, but I think this one will not do as well as Tit‚Äìfor‚ÄìTat.\n2¬†This strategy follows the Joss strategy featured in the 1984 book by R. Axelrod.3¬†Under the uniform distribution, every outcome is equally likely to occur so we should see outcomes less than .05 occur less than 5% of the time.To implement the random component needed to defect on 5% of cooperative responses, I will identify each time player 1 chooses to cooperate and then defect when randomly generated number from the uniform distribution is less than or equal to .053. If the randomly generated number is greater than my default, I‚Äôll revert back to the tit‚Äìfor‚Äìtat strategy.\n\n#&gt; @prob: probability of betrayal and cooperation\n#&gt; @default: percentage of cooperative responses on which player 2 betrays player 1\n\nprober &lt;- function(rounds, \n                   prob,\n                   choice,\n                   default,\n                   replace = TRUE,\n                   ...){\n  \n   # Check arguments\n  stopifnot({\n    is.integer(rounds)\n    is.double(prob)\n    is.logical(choice)\n    is.double(default)\n    is.logical(replace)\n  })\n  \n  choice_order &lt;- c(choice, 1 - choice)\n  p1 &lt;- logical(rounds)\n  p2 &lt;- logical(rounds)\n  \n  p1[1] &lt;- choice\n  p2[1] &lt;- TRUE  \n  \n  for (i in 2:rounds) {\n    if (choice_order[1] == TRUE) {\n      inv.prob &lt;- c(prob[2], prob[1])\n      p1[i] &lt;- sample(choice_order, size = 1, replace = replace, prob = inv.prob)\n    } else {\n      p1[i] &lt;- sample(choice_order, size = 1, replace = replace, prob = prob)\n    }\n    \n    if (p1[i - 1] == TRUE) {\n      if (runif(1) &lt; default) { # % chance to betray after cooperation\n        p2[i] &lt;- FALSE\n      } else {\n        p2[i] &lt;- TRUE\n      }\n    } else {\n      p2[i] &lt;- p1[i -1] \n    }\n  }\n  result &lt;- list(P1 = as.numeric(p1), \n                 P2 = as.numeric(p2))\n  return(result)\n}\n\ntable(prober(200,prob = c(.459,.237), choice = 0, default = .05, replace = T))\n#&gt;    P2\n#&gt; P1   0  1\n#&gt;   0 68 48\n#&gt;   1 51 33\n\n\nA less creative but more common solution is to simply emulate each of player 1 moves. Player 2 will never cooperate first unless player 1 chooses to cooperate. This copy cat algorithm is looking at the current round and not concerned with the previous moves.\n\n\ncopy.cat &lt;- function(rounds, \n                   prob,\n                   choice,\n                   replace = TRUE,\n                   ...){\n  \n # Check arguments\n  stopifnot({\n    is.integer(rounds)\n    is.double(prob)\n    is.logical(choice)\n    is.logical(replace)\n  })\n  \n  choice_order &lt;- c(choice, 1 - choice)\n  p1 &lt;- logical(rounds)\n  p2 &lt;- logical(rounds)\n  \n  p1[1] &lt;- choice\n  p2[1] &lt;- FALSE\n  \n  for (i in 2:rounds) {\n    if (choice_order[1] == TRUE) {\n      inv.prob &lt;- c(prob[2], prob[1])\n      p1[i] &lt;- sample(choice_order, size = 1, replace = replace, prob = inv.prob)\n    } else {\n      p1[i] &lt;- sample(choice_order, size = 1, replace = replace, prob = prob)\n    }\n    \n    p2[i] &lt;- p1[i]\n  }\n  result &lt;- list(P1 = as.numeric(p1),\n                 P2 = as.numeric(p2))\n  return(result)\n}\n\ntable(copy.cat(200,prob = c(.459,.237), choice = 0, replace = T))\n#&gt;    P2\n#&gt; P1    0   1\n#&gt;   0 140   0\n#&gt;   1   0  60\n\n\nThe last algorithm will play nice on the first round but will exact revenge on player 1 until the end of the game4.\n4¬†A copy of the aggressive Friedman‚Äôs algorithm.The key to achieve such vengeful results is to track when player 1 switches from betrayals to cooperation. Once we identify a betrayal, player 2 will no longer cooperate. I‚Äôll add one argument zero_switch to identify when player 1 chooses to defect, causing player 2 to defect on every move for the remainder of the game.\nWe have to pay careful attention to the choice probability here; if the probability of betrayal is higher than cooperation, the revenge algorithm will most likely never cooperate after the first few rounds. This player is a more revengeful fellow. Let‚Äôs see how to implement it.\n\n\nexact.revenge &lt;- function(rounds, prob, choice, replace = TRUE,...) {\n  # Check arguments\n  stopifnot({\n    is.integer(rounds)\n    is.double(prob)\n    is.logical(choice)\n    is.logical(replace)\n  })\n  \n  choice_order &lt;- c(choice, 1 - choice)\n  p1 &lt;- logical(rounds)\n  p2 &lt;- logical(rounds)\n  \n  p1[1] &lt;- choice\n  p2[1] &lt;- TRUE \n  \n  zero_switch &lt;- FALSE\n  \n  for (i in 2:rounds) {\n    # Generate player 1's move\n    if (choice_order[1] == TRUE) {\n      inv.prob &lt;- c(prob[2], prob[1])\n      p1[i] &lt;- sample(choice_order, size = 1, replace = replace, prob = inv.prob)\n    } else {\n      p1[i] &lt;- sample(choice_order, size = 1, replace = replace, prob = prob)\n    }\n    \n    # Player 2's response\n    if (p1[i - 1] == FALSE) {\n      zero_switch &lt;- TRUE\n    }\n    p2[i] &lt;- ifelse(zero_switch, FALSE, TRUE)\n  }\n  result &lt;- list(P1 = as.numeric(p1), \n                 P2 = as.numeric(p2))\n  return(result)\n}\n\ntable(exact.revenge(200,prob = c(.159,.437), choice = 1, replace = T))\n#&gt;    P2\n#&gt; P1    0   1\n#&gt;   0  53   1\n#&gt;   1 145   1"
  },
  {
    "objectID": "blog/2024/05/prisoners/index.html#not-so-quickly",
    "href": "blog/2024/05/prisoners/index.html#not-so-quickly",
    "title": "the iterated prisoners‚Äô dilemma",
    "section": "",
    "text": "Recently, I become intrigued by game theory algorithms, not because I absolutely love playing games, but because it offers a quantifiable, systematic way to understand human relationships. I find the certainty of science and systematization reassuring to some degree so when I learned about this game called ‚Äúthe prisoner‚Äô dilemma‚Äù, I thought it would fun to experiment and figure out the answer to this classic scenario. This game‚Äôs solution extends beyond hypothetical situations, addressing questions like: What‚Äôs the best strategy for handling conflict in various contexts‚Äîbe it a card game, a business deal, or interpersonal relationships? Should we always cooperate and risk betrayal?\nIn his landmark work, R. Axelrod1 said:\n1¬†The Evolution of Cooperation. Basic Books, Inc. New York, 1984\nThe Cooperation theory [here] is based upon an investigation of individuals who pursue their own self‚Äìinterest wihtout the aid of central authority to force them to cooperate with each other. The reason for assuming self‚Äìinterest is that it allows an examination of the difficult case when cooperation is not completely based upon a concern for others or upon the welfare of the groups as a whole.\n\nI‚Äôve heard the phrases ‚ÄúMeet in the middle‚Äù, ‚Äúalways compromise‚Äù or ‚Äúnever split the difference‚Äù but they all seem either idealistic or downright selfish. In a high-stakes situation, should we always cooperate? Yes or not so quickly!?.\n\nLet the prisoner‚Äôs dilemma answer these questions for us.\nThe iterated version of the dilemma was presented as a hypothetical scenario by R. Axelrod:\nTwo bank robbers happen to meet. They decide to pull a job together. The cops nab them, but without enough evidence to convict. They need a confession. And they know both robbers are unlikely to talk, since if neither implicates the other, the cops can keep them in jail for only 30 days.\nSo they put the two in separate cells. They go to the first prisoner and say: ‚ÄúIf you rat on your partner and he stays mum, we‚Äôll let you go and he‚Äôll do ten years.If you both rat on each other, you‚Äôll both do eight years.‚Äù Then they go to the second prisoner and say the same thing.\nThe first prisoner thinks it over. ‚ÄúIf he rats on me and I don‚Äôt rat on him, then I lose big-time. If I rat on him and he doesn‚Äôt rat on me, then I win big-time. Either way, the smart move is to rat on him. I‚Äôll just hope he‚Äôs a sucker and doesn‚Äôt rat on me.‚Äù The second prisoner reasons the same way. So they rat on each other, and the cops get their two convictions. If the prisoners had cooperated, both would have gotten off easy. Instead, the rational pursuit of self-interest has put them both in a world of pain.\nTo win the game, at least one player must cooperate in the face of betrayal, otherwise both contestants would face unfavorable outcomes.\n\nThe rules of the iterated prisoner‚Äôs dilemma:\n\nTwo players play 200 matches against each other and against an algorithm that betrayed or cooperated at random.\nPlayers obtain three points for mutual cooperation, one for a mutual betrayal, and five for the player who betrays when the other cooperates.\n\n\nI‚Äôll attempt to provide four solutions to this problem. The first algorithm will never be the first to betray and will copy the opponent‚Äôs previous choice. The second solution will betray in response to a cooperation five percent of the time; the third solution will not cooperate first and then imitate each of player 1‚Äôs choices, and the last one will never betray first, but will retaliate in turn on every remaining move until the end of the game.\nThe official winning strategy was the following:\n\nIn the first match-up, cooperate.\nIn every match-up after that, do what the opponent did in the preceding match-up.\n\nI‚Äôll imitate this strategy in the first algorithm.\nFirst,I‚Äôll create a function for player 2 that chooses to cooperate on the first attempt, and copies player 1‚Äôs previous choice on subsequent moves. To do this, I have to iterate over each of player 1‚Äôs choices, and store player 2‚Äôs replies in a new vector.\nTo determine the choice order I‚Äôll create a vector of length 2 with player 1‚Äôs original choice and subtract 1 from that choice to obtain the alternative. To create the vector of choices of length \\(n\\), I‚Äôll append player 1‚Äôs original choice to a vector of length \\(n-1\\) ensuring that the first choice is always in position 1 p1[1]. The resulting vector will be of length n.\nWe‚Äôll make a vector or player 2‚Äôs choices of length \\(n\\) equal to p1. The first choice will always be cooperation, and all subsequent choices will be player 1‚Äôs previous response p1[ i -1].\n\n\n\n\n\n\nAlways remember to initialize vectors and perform operations outside the loop, if possible. Doing this will sometimes make your function much, much faster.\n\n\n\n\n#&gt; @rounds: number of rounds or matches in one game\n#&gt; @prob: probability of betrayal and cooperation\n#&gt; @choice: first choice to start the game. Choice inversion will be applied if staring choice = 1\n#&gt; @replace: sampling with replacement based on choice order. A vector of length 2\n\ntit.for.tat &lt;- function(rounds, \n                        prob, \n                        choice,\n                        replace = TRUE,\n                        ...){\n  \n  # Check arguments\n  stopifnot({\n    is.integer(rounds)\n    is.double(prob)\n    is.logical(choice)\n    is.logical(replace)\n  })\n  \n  choice_order &lt;- c(choice, 1 - choice)\n  p1 &lt;- logical(rounds)\n  p2 &lt;- logical(rounds)\n  \n  \n  p1[1] &lt;- choice\n  p2[1] &lt;- TRUE  \n  \n  for (i in 2:rounds) {\n    if (choice_order[1] == TRUE) {\n      inv.prob &lt;- c(prob[2], prob[1])\n      p1[i] &lt;- sample(choice_order, size = 1, replace = replace, prob = inv.prob)\n    } else {\n      p1[i] &lt;- sample(choice_order, size = 1, replace = replace, prob = prob)\n    }\n    \n    p2[i] &lt;- p1[i - 1]\n  }\n  result &lt;- list(P1 = as.numeric(p1), \n                 P2 = as.numeric(p2))\n  return(result)\n}\n\ntable(tit.for.tat(200,prob = c(.459,.237), choice = 0, replace = T))\n#&gt;    P2\n#&gt; P1   0  1\n#&gt;   0 85 47\n#&gt;   1 47 21\n\n\nThe only difference between Tit‚Äìfor‚ÄìTat and the BSP2 is that we‚Äôre adding a random component that will cause player 2 to betray player 1 after a cooperation. Player 2 will always cooperate on the first round, but the algorithm will be less predictable than the previous one. I may be wrong, but I think this one will not do as well as Tit‚Äìfor‚ÄìTat.\n2¬†This strategy follows the Joss strategy featured in the 1984 book by R. Axelrod.3¬†Under the uniform distribution, every outcome is equally likely to occur so we should see outcomes less than .05 occur less than 5% of the time.To implement the random component needed to defect on 5% of cooperative responses, I will identify each time player 1 chooses to cooperate and then defect when randomly generated number from the uniform distribution is less than or equal to .053. If the randomly generated number is greater than my default, I‚Äôll revert back to the tit‚Äìfor‚Äìtat strategy.\n\n#&gt; @prob: probability of betrayal and cooperation\n#&gt; @default: percentage of cooperative responses on which player 2 betrays player 1\n\nprober &lt;- function(rounds, \n                   prob,\n                   choice,\n                   default,\n                   replace = TRUE,\n                   ...){\n  \n   # Check arguments\n  stopifnot({\n    is.integer(rounds)\n    is.double(prob)\n    is.logical(choice)\n    is.double(default)\n    is.logical(replace)\n  })\n  \n  choice_order &lt;- c(choice, 1 - choice)\n  p1 &lt;- logical(rounds)\n  p2 &lt;- logical(rounds)\n  \n  p1[1] &lt;- choice\n  p2[1] &lt;- TRUE  \n  \n  for (i in 2:rounds) {\n    if (choice_order[1] == TRUE) {\n      inv.prob &lt;- c(prob[2], prob[1])\n      p1[i] &lt;- sample(choice_order, size = 1, replace = replace, prob = inv.prob)\n    } else {\n      p1[i] &lt;- sample(choice_order, size = 1, replace = replace, prob = prob)\n    }\n    \n    if (p1[i - 1] == TRUE) {\n      if (runif(1) &lt; default) { # % chance to betray after cooperation\n        p2[i] &lt;- FALSE\n      } else {\n        p2[i] &lt;- TRUE\n      }\n    } else {\n      p2[i] &lt;- p1[i -1] \n    }\n  }\n  result &lt;- list(P1 = as.numeric(p1), \n                 P2 = as.numeric(p2))\n  return(result)\n}\n\ntable(prober(200,prob = c(.459,.237), choice = 0, default = .05, replace = T))\n#&gt;    P2\n#&gt; P1   0  1\n#&gt;   0 68 48\n#&gt;   1 51 33\n\n\nA less creative but more common solution is to simply emulate each of player 1 moves. Player 2 will never cooperate first unless player 1 chooses to cooperate. This copy cat algorithm is looking at the current round and not concerned with the previous moves.\n\n\ncopy.cat &lt;- function(rounds, \n                   prob,\n                   choice,\n                   replace = TRUE,\n                   ...){\n  \n # Check arguments\n  stopifnot({\n    is.integer(rounds)\n    is.double(prob)\n    is.logical(choice)\n    is.logical(replace)\n  })\n  \n  choice_order &lt;- c(choice, 1 - choice)\n  p1 &lt;- logical(rounds)\n  p2 &lt;- logical(rounds)\n  \n  p1[1] &lt;- choice\n  p2[1] &lt;- FALSE\n  \n  for (i in 2:rounds) {\n    if (choice_order[1] == TRUE) {\n      inv.prob &lt;- c(prob[2], prob[1])\n      p1[i] &lt;- sample(choice_order, size = 1, replace = replace, prob = inv.prob)\n    } else {\n      p1[i] &lt;- sample(choice_order, size = 1, replace = replace, prob = prob)\n    }\n    \n    p2[i] &lt;- p1[i]\n  }\n  result &lt;- list(P1 = as.numeric(p1),\n                 P2 = as.numeric(p2))\n  return(result)\n}\n\ntable(copy.cat(200,prob = c(.459,.237), choice = 0, replace = T))\n#&gt;    P2\n#&gt; P1    0   1\n#&gt;   0 140   0\n#&gt;   1   0  60\n\n\nThe last algorithm will play nice on the first round but will exact revenge on player 1 until the end of the game4.\n4¬†A copy of the aggressive Friedman‚Äôs algorithm.The key to achieve such vengeful results is to track when player 1 switches from betrayals to cooperation. Once we identify a betrayal, player 2 will no longer cooperate. I‚Äôll add one argument zero_switch to identify when player 1 chooses to defect, causing player 2 to defect on every move for the remainder of the game.\nWe have to pay careful attention to the choice probability here; if the probability of betrayal is higher than cooperation, the revenge algorithm will most likely never cooperate after the first few rounds. This player is a more revengeful fellow. Let‚Äôs see how to implement it.\n\n\nexact.revenge &lt;- function(rounds, prob, choice, replace = TRUE,...) {\n  # Check arguments\n  stopifnot({\n    is.integer(rounds)\n    is.double(prob)\n    is.logical(choice)\n    is.logical(replace)\n  })\n  \n  choice_order &lt;- c(choice, 1 - choice)\n  p1 &lt;- logical(rounds)\n  p2 &lt;- logical(rounds)\n  \n  p1[1] &lt;- choice\n  p2[1] &lt;- TRUE \n  \n  zero_switch &lt;- FALSE\n  \n  for (i in 2:rounds) {\n    # Generate player 1's move\n    if (choice_order[1] == TRUE) {\n      inv.prob &lt;- c(prob[2], prob[1])\n      p1[i] &lt;- sample(choice_order, size = 1, replace = replace, prob = inv.prob)\n    } else {\n      p1[i] &lt;- sample(choice_order, size = 1, replace = replace, prob = prob)\n    }\n    \n    # Player 2's response\n    if (p1[i - 1] == FALSE) {\n      zero_switch &lt;- TRUE\n    }\n    p2[i] &lt;- ifelse(zero_switch, FALSE, TRUE)\n  }\n  result &lt;- list(P1 = as.numeric(p1), \n                 P2 = as.numeric(p2))\n  return(result)\n}\n\ntable(exact.revenge(200,prob = c(.159,.437), choice = 1, replace = T))\n#&gt;    P2\n#&gt; P1    0   1\n#&gt;   0  53   1\n#&gt;   1 145   1"
  },
  {
    "objectID": "blog/2024/05/prisoners/index.html#algorithm-face-off",
    "href": "blog/2024/05/prisoners/index.html#algorithm-face-off",
    "title": "the iterated prisoners‚Äô dilemma",
    "section": "algorithm face off",
    "text": "algorithm face off\nNow that all four algorithms are created, we need a function to evaluate the overall performance in total points after 200 rounds.\nFirst, we need an outcome matrix to store the outcome of each choice combination. Then, I have to create a function that repeatedly compares algorithms over n number of games. To do this, I will update the choice order for each game, if necessary; store total number of choices per game in two vectors, one for each player, create a list and evaluate choice outcome against the outcome matrix, and then sum each player‚Äôs score in the new list to find the total number of points per game. Finally, I would have to calculate the average number of total points per game and compare the algorithms.\nHowever, not every algorithm takes the same list of arguments. The prober algorithm requires a default that is not specified anywhere else, and I must implement a comparison function that will take a default probability but only apply it to one of the algorithms no matter its order in the list. To do this, I‚Äôll check each argument entered in the function and create two lists, one for the prober algorithm and a second for the second algorithm. The first list will contain the default argument and, if there‚Äôs a value specified, apply it to prober, the second will only take a default probability if the algorithm requires a default.\n\n#&gt; arguments include:\n#&gt;  @alg: algorithms to compare\n#&gt;  @rounds: number of rounds in a game\n#&gt;  @prob:   probability of betrayal and cooperation.\n#&gt;  @choice: starting choice.\n#&gt;  @default: percentage of cooperative responses on which player 2 betrays player 1\n#&gt;  @iter: how many games of `n` rounds should be played.\n\ncomp.alg &lt;- function(alg,\n                     iter = NULL,\n                     rounds,\n                     prob,\n                     choice,\n                     replace = TRUE,\n                     default = NULL){\n  #Check arguments\n  stopifnot({\n    is.list(alg)\n    is.numeric(iter) && iter &gt; 0})\n  \n  out &lt;- matrix(c(3,5,0,1), nrow = 2, byrow = TRUE)\n        rownames(out) &lt;- c(\"P1.C\",\"P1.B\")\n        colnames(out) &lt;- c(\"P2.C\",\"P2.B\")\n        \ncreate.args &lt;- function(func,common_args, default){\n  \n  fun_args &lt;- names(formals(func))\n  args &lt;- common_args[names(common_args)%in% fun_args]\n  if(\"default\" %in% fun_args && !is.null(default)){\n    args$default &lt;- default\n  }\n  args\n}\n\ncommon_args &lt;- list(rounds = rounds, \n                        prob = prob,\n                        choice = choice,\n                        replace = TRUE)\n\np1_args &lt;- create.args(alg[[1]], common_args, default)\np2_args &lt;- create.args(alg[[2]], common_args,default)\n  \n  play.game &lt;- function(rounds, \n                        prob,\n                        choice, \n                        default = default,\n                        replace = TRUE) {\n    \n    p1 &lt;- do.call(alg[[1]],p1_args)\n    p2 &lt;- do.call(alg[[2]],p2_args)\n\n   \n  do.score &lt;- function(P1,P2){ # function with O(n) complexity with two ind. for loops\n    \n    n1 &lt;- length(unlist(P1[[1]]))\n    n2 &lt;- length(unlist(P2[[1]]))\n    \n    game_res1 &lt;- data.frame(A1P1 = numeric(n1), \n                           A1P2 = numeric(n1))\n    \n    game_res2 &lt;- data.frame(A2P1 = numeric(n2), \n                           A2P2 = numeric(n2))\n    \n    for(i in seq_along(P1[[1]])){\n      c1 &lt;- P1[[1]][i]\n      c2 &lt;- P1[[2]][i]\n      \n      p1_score &lt;- out[c1 + 1, c2 + 1]\n      p2_score &lt;- t(out)[c1 + 1, c2 + 1]\n      \n      game_res1$A1P1[i] &lt;- p1_score\n      game_res1$A1P2[i] &lt;- p2_score\n    }\n    \n    for (i in seq_along(P2[[1]])){\n      c1 &lt;- P2[[1]][i]\n      c2 &lt;- P2[[2]][i]\n      \n      p1_score &lt;- out[c1 + 1, c2 + 1]\n      p2_score &lt;- t(out)[c1 + 1, c2 + 1]\n      \n      game_res2$A2P1[i] &lt;- p1_score\n      game_res2$A2P2[i] &lt;- p2_score\n    }\n     df_res &lt;- data.frame(game_res1,game_res2)\n     results &lt;- colSums(df_res)\n  }\n  out_game &lt;- do.score(p1,p2)\n  \n  }\n  \n  boot.results &lt;- list2DF(replicate(iter, play.game(rounds = rounds,\n                                prob = prob,\n                                choice = choice,\n                                replace = replace), simplify = FALSE))\n  \n  results &lt;- as.matrix(do.call(rbind,boot.results))\n  \n  \n  return(as.data.frame(results))\n}\n\n#Let's test it\ntest &lt;- comp.alg(c(copy.cat, tit.for.tat), \n                 iter = 500, \n                 rounds = 200, \n                 prob = c(.345, .231), \n                 choice = 0) |&gt; rename(\"CC.P1\" = \"A1P1\",\n                                       \"CC.P2\" = \"A1P2\",\n                                       \"TFT.P1\" = \"A2P1\",\n                                       \"TFT.P2\" = \"A2P2\")\n\nhead(test)\n#&gt;   CC.P1 CC.P2 TFT.P1 TFT.P2\n#&gt; 1   440   440    514    509\n#&gt; 2   458   458    494    494\n#&gt; 3   432   432    473    468\n#&gt; 4   430   430    495    490\n#&gt; 5   426   426    479    474\n#&gt; 6   432   432    485    485\n\nindividual algorithm performance\nLet‚Äôs now compare each algorithm‚Äôs performance based on total points obtained per game. Again, the logic here is the same: bootstrap the mean number of points per game and compare them using the comp.alg function which takes two algorithms at once and returns a data frame with four columns, one column for each player for two algorithms.\naverage cooperative response\nComputing the average cooperative responses by algorithm after playing 500 games of 200 rounds each should help us understand which algorithm tends to play nice and which ones are more selfish. For the sake of reproducibility, we‚Äôve set a seed and established an equal, fixed probability of defection and cooperation across algorithms.\n\nCode for algorithm median cooperationmean_df &lt;- data.frame(Median = c(replicate(500,median(\n                                sample(copy.cat(200,c(.35,.27),0)$P2,\n                                       replace = T))),\n                              replicate(500,median(\n                                sample(prober(200,c(.35,.27),0,.05)$P2,\n                                       replace = T))),\n                              replicate(500,median(\n                                sample(tit.for.tat(200,c(.35,.27),0)$P2,\n                                       replace = T))),\n                              replicate(500,median(\n                                sample(exact.revenge(200,c(.35,.27),0)$P2,\n                                       replace = T)))),\n                      kind = factor(rep(\n                        c(\"Copy.Cat\", \"Prober\", \"TFT\", \"Revenge\"), \n                                    each = 500),\n    levels = c(\"Copy.Cat\", \"Prober\", \"TFT\", \"Revenge\")))\n\nclrs &lt;- c(\n  \"#FFBE00\",  # MCRN yellow\n  \"#B92F0A\",  # MCRN red\n  \"#7C225C\",  # MCRN maroon\n  \"#394DAA\"   # MCRN Blue\n)\np0 &lt;- ggplot(mean_df, aes(x = mean, fill = kind)) +\n     geom_density(alpha = .45) +\n  ylim(0,25) +\n  labs(x = \"Avg. cooperative response\") +\n  scale_fill_manual(values = clrs) +\n  labs(colour = \"Algorithm\")\n\n\n\n\n\nAverage cooperative responses\n\n\n\n\n\n\n\nThe cooperative response plot shows that, on average, the tit‚Äìfor‚Äìtat algorithm cooperates more often than the vengeful and the prober algorithms, but just as much as copy.cat5.\n5¬†I used the Wilcoxon rank sum test to compute the difference in medians and check if the algorithm distributions are stochastically equivalent. It‚Äôs not clear whether the prober algorithm is equivalent to tit.for.tat, but the test shows a statistically significant difference in the algorithms‚Äô median cooperative responses.\nCode\nwilcox_gt &lt;- mean_df |&gt; \n  filter(kind == c(\"TFT\",\"Prober\")) |&gt; \n  pivot_longer(cols = -kind, names_to = \"vars\", \n               values_to = \"values\") |&gt;\n  group_by(vars) |&gt; \n  summarize(\n  Estimate = wilcox.test(values~kind, conf.int = T)$estimate,\n  Sig. = wilcox.test(values~kind, conf.int = T)$p.value \n  ) |&gt; \n  gt() |&gt; \n  tab_header(\n    title = md(\"*Comparison of Tit√óTat and Prober cooperative responses*\")\n    ) |&gt;\n  cols_label(vars = md(\"**Estimate**\"),\n             Estimate = md(\"**Difference in estimate**\"),\n            Sig. = md(\"**p-value**\")) |&gt;\n  cols_align(align = \"center\") |&gt;\n  opt_table_font(font = google_font(\"EB Garamond\"),\n                 weight = 400,style = \"plain\", add = TRUE) |&gt;\n  tab_style(style = cell_text(font = google_font(\"Ubuntu\")),\n            locations = cells_body()) |&gt;\n   tab_options(column_labels.font.weight = \"bold\",\n              row_group.font.weight = \"bold\") |&gt;\n  data_color(rows = everything(),\n             palette = \"#f9f9f9\")\n\nwilcox_gt\n\n\n\n\n\n\nComparison of Tit√óTat and Prober cooperative responses\n\n\nEstimate\nDifference in estimate\np-value\n\n\n\nMedian\n-2.38e-05\n0.0451\n\n\n\n\n\nAxelrod believed that, on average, ‚Äúnice‚Äù algorithms would perform better than ‚Äú mean and deceitful‚Äù ones like exact.revenge and prober, and we can clearly see that our most vengeful algorithm performs poorly on the cooperative front, with a mean cooperation of .0055 per game, about once per game.\nBased on the algorithm‚Äôs cooperative response we can then visualize and compute the final score distribution (in total points) for each player after 500 games of 200 rounds each. We‚Äôll see that, by defecting often and without provocation, the second player typically scores much higher than player 1. However, when player 2 chooses to not betray without provocation or imitate the first‚Äôs player current choices both players end up with higher and approximately equal scores. Because of this willingness to cooperate, according to Axelrod, the nice algorithms tend to be more conducive to cooperation and less prone to conflict.\n\nCode for data manipulation & plotstest2 &lt;- comp.alg(c(exact.revenge, prober), \n                 iter = 500, \n                 rounds = 200, \n                 prob = c(.345, .231), \n                 choice = 0,\n                 default = .10) |&gt; rename(\"R.P1\" = \"A1P1\",\n                                          \"R.P2\" = \"A1P2\",\n                                          \"Pr.P1\" = \"A2P1\",\n                                          \"Pr.P2\" = \"A2P2\")\n\nperf_df &lt;- cbind(test,test2) |&gt; pivot_longer(cols = everything(), \n               names_to = c(\"Algorithm\", \"Player\"),\n               names_pattern = \"([^.]+)\\\\.(P\\\\d)\",\n               values_to = \"Score\") |&gt;\n  mutate(Algorithm = case_when(\n           Algorithm == \"R\" ~ \"Revenge\",\n           Algorithm == \"Pr\" ~ \"Prober\",\n           Algorithm == \"CC\" ~\"Copy.Cat\",\n           Algorithm == \"TFT\" ~ \"Tit√óTat\",\n           TRUE ~Algorithm\n         ),\n         Algorithm = factor(Algorithm),\n         Player = factor(Player)) |&gt;\n  arrange(Algorithm, Player) |&gt;\n  group_by(Algorithm, Player)\n\n#&gt; str(perf_df)\n\n p1 &lt;- ggplot(perf_df, aes(Score, fill= Player)) +\n  geom_density(alpha = .45) +\n  labs(title = NULL,\n       x = NULL,\n       y = NULL) + \n  scale_fill_manual(values = clrs)\n\n \n p2 &lt;- ggplot(perf_df, aes(Score, fill= Algorithm)) +\n  geom_density(alpha = .45) +\n  labs(title = NULL,\n       x = \"Score\",\n       y = NULL) + \n  scale_fill_manual(values = clrs) \n \n#&gt; p1/p2\n  \n\n\n\n\n\n\n\n\n\n\nThese two plots show the performance of both players and the four algorithms, and we can see that the most extreme results are obtained using the exact.revenge algorithm. The density curves for this algorithm are touching the extremes on the left and right, showing that one player will always under perform while the other one, typically the second one, will outperform his opponent. This algorithm is a ‚Äúsneaky‚Äù one because player 1 is not able to confidently predict his opponent‚Äôs moves. Regardless of his choice, after the first betrayal, player 2 will never cooperate again.\nTo my surprise, the prober algorithm returned a more favorable score for player 2 than the tit.for.tat or the copy.cat algorithm; however, the nice algorithms always favored both players, not just player 2.\n\nCode sumperf_gt &lt;- perf_df |&gt; summarise(Score = mean(Score)) |&gt;\n  arrange(Algorithm) |&gt;\n  as_tibble() |&gt; gt() |&gt; \n  tab_header(title = md(\"*Average Player Score by Algorithm*\")) |&gt;\n  cols_label(Algorithm = md(\"**Algorithm**\"),\n             Player = md(\"**Player**\"),\n            Score = md(\"**Score**\")) |&gt;\n  opt_table_font(font = google_font(\"EB Garamond\"),\n                 weight = 400,style = \"plain\", add = TRUE) |&gt;\n  tab_style(style = cell_text(font = google_font(\"Ubuntu\")),\n            locations = cells_body()) |&gt;\n   tab_options(column_labels.font.weight = \"bold\",\n              row_group.font.weight = \"bold\") |&gt;\n  data_color(rows = everything(),\n             palette = \"#f9f9f9\") |&gt;\n  opt_interactive(use_compact_mode = TRUE, use_highlight = TRUE)\n \n sumperf_gt\n\n\n\n\nAverage Player Score by Algorithm\n\n\n\n\n\n\n\nNevertheless, regardless of which algorithm we used, player 1‚Äôs score is, on average, lower than player 2, even if the nice algorithms tend to equalize the scores and may result in less conflict as Axelrod described.\npractical implications\nAmong all the algorithms submitted to Axelrod, the top performer was Tit‚Äìfor‚Äìtat because it was ‚Äúnice‚Äù. Algorithms that always betrayed or were ‚Äúsneaky‚Äù were more likely to end up in a state of conflict. Our custom algorithms also showed this behavior, both players thrived when cooperation was a priority for one of the players. In our case, the tit.for.tat algorithm outperformed others in this regard even if it didn‚Äôt achieve the maximum number of points like the exact.revenge algorithm.\nBased on this short experiment, we can conclude that cooperation is better than conflict for all parties involved. We should accept betrayal and quickly forgive to attain a more favorable outcome. We shouldn‚Äôt be ‚Äúpushovers‚Äù and always cooperate regardless of our opponent‚Äôs actions. Instead,we should be just and merciful, meting out justice when previously betrayed but extending mercy when our opponent doesn‚Äôt deserve it.\nHere are some rules for strategic cooperation derived from our algorithms:\n\nAvoid unnecessary conflict by cooperating as long as your opponent does.\nIf your opponent betrays you without provocation‚Äî respond in kind‚Ä¶once.\nThen forgive the betrayal, and cooperate again.\nBe clear and predictable so your opponent knows how you act and can plan accordingly."
  }
]